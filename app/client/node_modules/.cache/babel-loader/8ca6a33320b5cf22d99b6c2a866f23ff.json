{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nconst Collection = require('./Collection');\n\nconst collections = require('./collections');\n\nconst getParser = require('./getParser');\n\nconst matchNode = require('./matchNode');\n\nconst recast = require('recast');\n\nconst template = require('./template');\n\nconst Node = recast.types.namedTypes.Node;\nconst NodePath = recast.types.NodePath; // Register all built-in collections\n\nfor (var name in collections) {\n  collections[name].register();\n}\n/**\n * Main entry point to the tool. The function accepts multiple different kinds\n * of arguments as a convenience. In particular the function accepts either\n *\n * - a string containing source code\n *   The string is parsed with Recast\n * - a single AST node\n * - a single node path\n * - an array of nodes\n * - an array of node paths\n *\n * @exports jscodeshift\n * @param {Node|NodePath|Array|string} source\n * @param {Object} options Options to pass to Recast when passing source code\n * @return {Collection}\n */\n\n\nfunction core(source, options) {\n  return typeof source === 'string' ? fromSource(source, options) : fromAST(source);\n}\n/**\n * Returns a collection from a node, node path, array of nodes or array of node\n * paths.\n *\n * @ignore\n * @param {Node|NodePath|Array} source\n * @return {Collection}\n */\n\n\nfunction fromAST(ast) {\n  if (Array.isArray(ast)) {\n    if (ast[0] instanceof NodePath || ast.length === 0) {\n      return Collection.fromPaths(ast);\n    } else if (Node.check(ast[0])) {\n      return Collection.fromNodes(ast);\n    }\n  } else {\n    if (ast instanceof NodePath) {\n      return Collection.fromPaths([ast]);\n    } else if (Node.check(ast)) {\n      return Collection.fromNodes([ast]);\n    }\n  }\n\n  throw new TypeError('Received an unexpected value ' + Object.prototype.toString.call(ast));\n}\n\nfunction fromSource(source, options) {\n  if (!options) {\n    options = {};\n  }\n\n  if (!options.parser) {\n    options.parser = getParser();\n  }\n\n  return fromAST(recast.parse(source, options));\n}\n/**\n * Utility function to match a node against a pattern.\n * @augments core\n * @static\n * @param {Node|NodePath|Object} path\n * @parma {Object} filter\n * @return boolean\n */\n\n\nfunction match(path, filter) {\n  if (!(path instanceof NodePath)) {\n    if (typeof path.get === 'function') {\n      path = path.get();\n    } else {\n      path = {\n        value: path\n      };\n    }\n  }\n\n  return matchNode(path.value, filter);\n}\n\nconst plugins = [];\n/**\n * Utility function for registering plugins.\n *\n * Plugins are simple functions that are passed the core jscodeshift instance.\n * They should extend jscodeshift by calling `registerMethods`, etc.\n * This method guards against repeated registrations (the plugin callback will only be called once).\n *\n * @augments core\n * @static\n * @param {Function} plugin\n */\n\nfunction use(plugin) {\n  if (plugins.indexOf(plugin) === -1) {\n    plugins.push(plugin);\n    plugin(core);\n  }\n}\n/**\n * Returns a version of the core jscodeshift function \"bound\" to a specific\n * parser.\n *\n * @augments core\n * @static\n */\n\n\nfunction withParser(parser) {\n  if (typeof parser === 'string') {\n    parser = getParser(parser);\n  }\n\n  const newCore = function (source, options) {\n    if (options && !options.parser) {\n      options.parser = parser;\n    } else {\n      options = {\n        parser\n      };\n    }\n\n    return core(source, options);\n  };\n\n  return enrichCore(newCore, parser);\n}\n/**\n* The ast-types library\n* @external astTypes\n* @see {@link https://github.com/benjamn/ast-types}\n*/\n\n\nfunction enrichCore(core, parser) {\n  // add builders and types to the function for simple access\n  Object.assign(core, recast.types.namedTypes);\n  Object.assign(core, recast.types.builders);\n  core.registerMethods = Collection.registerMethods;\n  /**\n  * @augments core\n  * @type external:astTypes\n  */\n\n  core.types = recast.types;\n  core.match = match;\n  core.template = template(parser); // add mappings and filters to function\n\n  core.filters = {};\n  core.mappings = {};\n\n  for (const name in collections) {\n    if (collections[name].filters) {\n      core.filters[name] = collections[name].filters;\n    }\n\n    if (collections[name].mappings) {\n      core.mappings[name] = collections[name].mappings;\n    }\n  }\n\n  core.use = use;\n  core.withParser = withParser;\n  return core;\n}\n\nmodule.exports = enrichCore(core, getParser());","map":{"version":3,"names":["Collection","require","collections","getParser","matchNode","recast","template","Node","types","namedTypes","NodePath","name","register","core","source","options","fromSource","fromAST","ast","Array","isArray","length","fromPaths","check","fromNodes","TypeError","Object","prototype","toString","call","parser","parse","match","path","filter","get","value","plugins","use","plugin","indexOf","push","withParser","newCore","enrichCore","assign","builders","registerMethods","filters","mappings","module","exports"],"sources":["/home/haziz1/node_modules/jscodeshift/src/core.js"],"sourcesContent":["\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\nconst Collection = require('./Collection');\n\nconst collections = require('./collections');\nconst getParser = require('./getParser');\nconst matchNode = require('./matchNode');\nconst recast = require('recast');\nconst template = require('./template');\n\nconst Node = recast.types.namedTypes.Node;\nconst NodePath = recast.types.NodePath;\n\n// Register all built-in collections\nfor (var name in collections) {\n  collections[name].register();\n}\n\n/**\n * Main entry point to the tool. The function accepts multiple different kinds\n * of arguments as a convenience. In particular the function accepts either\n *\n * - a string containing source code\n *   The string is parsed with Recast\n * - a single AST node\n * - a single node path\n * - an array of nodes\n * - an array of node paths\n *\n * @exports jscodeshift\n * @param {Node|NodePath|Array|string} source\n * @param {Object} options Options to pass to Recast when passing source code\n * @return {Collection}\n */\nfunction core(source, options) {\n  return typeof source === 'string' ?\n    fromSource(source, options) :\n    fromAST(source);\n}\n\n/**\n * Returns a collection from a node, node path, array of nodes or array of node\n * paths.\n *\n * @ignore\n * @param {Node|NodePath|Array} source\n * @return {Collection}\n */\nfunction fromAST(ast) {\n  if (Array.isArray(ast)) {\n    if (ast[0] instanceof NodePath || ast.length === 0) {\n      return Collection.fromPaths(ast);\n    } else if (Node.check(ast[0])) {\n      return Collection.fromNodes(ast);\n    }\n  } else {\n    if (ast instanceof NodePath) {\n      return Collection.fromPaths([ast]);\n    } else if (Node.check(ast)) {\n      return Collection.fromNodes([ast]);\n    }\n  }\n  throw new TypeError(\n    'Received an unexpected value ' + Object.prototype.toString.call(ast)\n  );\n}\n\nfunction fromSource(source, options) {\n  if (!options) {\n    options = {};\n  }\n  if (!options.parser) {\n    options.parser = getParser();\n  }\n  return fromAST(recast.parse(source, options));\n}\n\n/**\n * Utility function to match a node against a pattern.\n * @augments core\n * @static\n * @param {Node|NodePath|Object} path\n * @parma {Object} filter\n * @return boolean\n */\nfunction match(path, filter) {\n  if (!(path instanceof NodePath)) {\n    if (typeof path.get === 'function') {\n      path = path.get();\n    } else {\n      path = {value: path};\n    }\n  }\n  return matchNode(path.value, filter);\n}\n\nconst plugins = [];\n\n/**\n * Utility function for registering plugins.\n *\n * Plugins are simple functions that are passed the core jscodeshift instance.\n * They should extend jscodeshift by calling `registerMethods`, etc.\n * This method guards against repeated registrations (the plugin callback will only be called once).\n *\n * @augments core\n * @static\n * @param {Function} plugin\n */\nfunction use(plugin) {\n  if (plugins.indexOf(plugin) === -1) {\n    plugins.push(plugin);\n    plugin(core);\n  }\n}\n\n/**\n * Returns a version of the core jscodeshift function \"bound\" to a specific\n * parser.\n *\n * @augments core\n * @static\n */\nfunction withParser(parser) {\n  if (typeof parser === 'string') {\n    parser = getParser(parser);\n  }\n\n  const newCore = function(source, options) {\n    if (options && !options.parser) {\n      options.parser = parser;\n    } else {\n      options = {parser};\n    }\n    return core(source, options);\n  };\n\n  return enrichCore(newCore, parser);\n}\n\n/**\n* The ast-types library\n* @external astTypes\n* @see {@link https://github.com/benjamn/ast-types}\n*/\n\nfunction enrichCore(core, parser) {\n  // add builders and types to the function for simple access\n  Object.assign(core, recast.types.namedTypes);\n  Object.assign(core, recast.types.builders);\n  core.registerMethods = Collection.registerMethods;\n  /**\n  * @augments core\n  * @type external:astTypes\n  */\n  core.types = recast.types;\n  core.match = match;\n  core.template = template(parser);\n\n  // add mappings and filters to function\n  core.filters = {};\n  core.mappings = {};\n  for (const name in collections) {\n    if (collections[name].filters) {\n      core.filters[name] = collections[name].filters;\n    }\n    if (collections[name].mappings) {\n      core.mappings[name] = collections[name].mappings;\n    }\n  }\n  core.use = use;\n  core.withParser = withParser;\n  return core;\n}\n\nmodule.exports = enrichCore(core, getParser());\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}