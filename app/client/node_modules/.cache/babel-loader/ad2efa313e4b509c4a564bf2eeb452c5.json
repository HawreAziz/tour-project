{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar tslib_1 = require(\"tslib\");\n\nvar assert_1 = tslib_1.__importDefault(require(\"assert\"));\n\nvar types = tslib_1.__importStar(require(\"ast-types\"));\n\nvar util = tslib_1.__importStar(require(\"./util\"));\n\nvar n = types.namedTypes;\nvar isArray = types.builtInTypes.array;\nvar isNumber = types.builtInTypes.number;\nvar PRECEDENCE = {};\n[[\"||\"], [\"&&\"], [\"|\"], [\"^\"], [\"&\"], [\"==\", \"===\", \"!=\", \"!==\"], [\"<\", \">\", \"<=\", \">=\", \"in\", \"instanceof\"], [\">>\", \"<<\", \">>>\"], [\"+\", \"-\"], [\"*\", \"/\", \"%\"], [\"**\"]].forEach(function (tier, i) {\n  tier.forEach(function (op) {\n    PRECEDENCE[op] = i;\n  });\n});\n\nvar FastPath = function FastPath(value) {\n  assert_1.default.ok(this instanceof FastPath);\n  this.stack = [value];\n};\n\nvar FPp = FastPath.prototype; // Static convenience function for coercing a value to a FastPath.\n\nFastPath.from = function (obj) {\n  if (obj instanceof FastPath) {\n    // Return a defensive copy of any existing FastPath instances.\n    return obj.copy();\n  }\n\n  if (obj instanceof types.NodePath) {\n    // For backwards compatibility, unroll NodePath instances into\n    // lightweight FastPath [..., name, value] stacks.\n    var copy = Object.create(FastPath.prototype);\n    var stack = [obj.value];\n\n    for (var pp = void 0; pp = obj.parentPath; obj = pp) stack.push(obj.name, pp.value);\n\n    copy.stack = stack.reverse();\n    return copy;\n  } // Otherwise use obj as the value of the new FastPath instance.\n\n\n  return new FastPath(obj);\n};\n\nFPp.copy = function copy() {\n  var copy = Object.create(FastPath.prototype);\n  copy.stack = this.stack.slice(0);\n  return copy;\n}; // The name of the current property is always the penultimate element of\n// this.stack, and always a String.\n\n\nFPp.getName = function getName() {\n  var s = this.stack;\n  var len = s.length;\n\n  if (len > 1) {\n    return s[len - 2];\n  } // Since the name is always a string, null is a safe sentinel value to\n  // return if we do not know the name of the (root) value.\n\n\n  return null;\n}; // The value of the current property is always the final element of\n// this.stack.\n\n\nFPp.getValue = function getValue() {\n  var s = this.stack;\n  return s[s.length - 1];\n};\n\nFPp.valueIsDuplicate = function () {\n  var s = this.stack;\n  var valueIndex = s.length - 1;\n  return s.lastIndexOf(s[valueIndex], valueIndex - 1) >= 0;\n};\n\nfunction getNodeHelper(path, count) {\n  var s = path.stack;\n\n  for (var i = s.length - 1; i >= 0; i -= 2) {\n    var value = s[i];\n\n    if (n.Node.check(value) && --count < 0) {\n      return value;\n    }\n  }\n\n  return null;\n}\n\nFPp.getNode = function getNode(count) {\n  if (count === void 0) {\n    count = 0;\n  }\n\n  return getNodeHelper(this, ~~count);\n};\n\nFPp.getParentNode = function getParentNode(count) {\n  if (count === void 0) {\n    count = 0;\n  }\n\n  return getNodeHelper(this, ~~count + 1);\n}; // The length of the stack can be either even or odd, depending on whether\n// or not we have a name for the root value. The difference between the\n// index of the root value and the index of the final value is always\n// even, though, which allows us to return the root value in constant time\n// (i.e. without iterating backwards through the stack).\n\n\nFPp.getRootValue = function getRootValue() {\n  var s = this.stack;\n\n  if (s.length % 2 === 0) {\n    return s[1];\n  }\n\n  return s[0];\n}; // Temporarily push properties named by string arguments given after the\n// callback function onto this.stack, then call the callback with a\n// reference to this (modified) FastPath object. Note that the stack will\n// be restored to its original state after the callback is finished, so it\n// is probably a mistake to retain a reference to the path.\n\n\nFPp.call = function call(callback\n/*, name1, name2, ... */\n) {\n  var s = this.stack;\n  var origLen = s.length;\n  var value = s[origLen - 1];\n  var argc = arguments.length;\n\n  for (var i = 1; i < argc; ++i) {\n    var name = arguments[i];\n    value = value[name];\n    s.push(name, value);\n  }\n\n  var result = callback(this);\n  s.length = origLen;\n  return result;\n}; // Similar to FastPath.prototype.call, except that the value obtained by\n// accessing this.getValue()[name1][name2]... should be array-like. The\n// callback will be called with a reference to this path object for each\n// element of the array.\n\n\nFPp.each = function each(callback\n/*, name1, name2, ... */\n) {\n  var s = this.stack;\n  var origLen = s.length;\n  var value = s[origLen - 1];\n  var argc = arguments.length;\n\n  for (var i = 1; i < argc; ++i) {\n    var name = arguments[i];\n    value = value[name];\n    s.push(name, value);\n  }\n\n  for (var i = 0; i < value.length; ++i) {\n    if (i in value) {\n      s.push(i, value[i]); // If the callback needs to know the value of i, call\n      // path.getName(), assuming path is the parameter name.\n\n      callback(this);\n      s.length -= 2;\n    }\n  }\n\n  s.length = origLen;\n}; // Similar to FastPath.prototype.each, except that the results of the\n// callback function invocations are stored in an array and returned at\n// the end of the iteration.\n\n\nFPp.map = function map(callback\n/*, name1, name2, ... */\n) {\n  var s = this.stack;\n  var origLen = s.length;\n  var value = s[origLen - 1];\n  var argc = arguments.length;\n\n  for (var i = 1; i < argc; ++i) {\n    var name = arguments[i];\n    value = value[name];\n    s.push(name, value);\n  }\n\n  var result = new Array(value.length);\n\n  for (var i = 0; i < value.length; ++i) {\n    if (i in value) {\n      s.push(i, value[i]);\n      result[i] = callback(this, i);\n      s.length -= 2;\n    }\n  }\n\n  s.length = origLen;\n  return result;\n}; // Returns true if the node at the tip of the path is wrapped with\n// parentheses, OR if the only reason the node needed parentheses was that\n// it couldn't be the first expression in the enclosing statement (see\n// FastPath#canBeFirstInStatement), and it has an opening `(` character.\n// For example, the FunctionExpression in `(function(){}())` appears to\n// need parentheses only because it's the first expression in the AST, but\n// since it happens to be preceded by a `(` (which is not apparent from\n// the AST but can be determined using FastPath#getPrevToken), there is no\n// ambiguity about how to parse it, so it counts as having parentheses,\n// even though it is not immediately followed by a `)`.\n\n\nFPp.hasParens = function () {\n  var node = this.getNode();\n  var prevToken = this.getPrevToken(node);\n\n  if (!prevToken) {\n    return false;\n  }\n\n  var nextToken = this.getNextToken(node);\n\n  if (!nextToken) {\n    return false;\n  }\n\n  if (prevToken.value === \"(\") {\n    if (nextToken.value === \")\") {\n      // If the node preceded by a `(` token and followed by a `)` token,\n      // then of course it has parentheses.\n      return true;\n    } // If this is one of the few Expression types that can't come first in\n    // the enclosing statement because of parsing ambiguities (namely,\n    // FunctionExpression, ObjectExpression, and ClassExpression) and\n    // this.firstInStatement() returns true, and the node would not need\n    // parentheses in an expression context because this.needsParens(true)\n    // returns false, then it just needs an opening parenthesis to resolve\n    // the parsing ambiguity that made it appear to need parentheses.\n\n\n    var justNeedsOpeningParen = !this.canBeFirstInStatement() && this.firstInStatement() && !this.needsParens(true);\n\n    if (justNeedsOpeningParen) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\nFPp.getPrevToken = function (node) {\n  node = node || this.getNode();\n  var loc = node && node.loc;\n  var tokens = loc && loc.tokens;\n\n  if (tokens && loc.start.token > 0) {\n    var token = tokens[loc.start.token - 1];\n\n    if (token) {\n      // Do not return tokens that fall outside the root subtree.\n      var rootLoc = this.getRootValue().loc;\n\n      if (util.comparePos(rootLoc.start, token.loc.start) <= 0) {\n        return token;\n      }\n    }\n  }\n\n  return null;\n};\n\nFPp.getNextToken = function (node) {\n  node = node || this.getNode();\n  var loc = node && node.loc;\n  var tokens = loc && loc.tokens;\n\n  if (tokens && loc.end.token < tokens.length) {\n    var token = tokens[loc.end.token];\n\n    if (token) {\n      // Do not return tokens that fall outside the root subtree.\n      var rootLoc = this.getRootValue().loc;\n\n      if (util.comparePos(token.loc.end, rootLoc.end) <= 0) {\n        return token;\n      }\n    }\n  }\n\n  return null;\n}; // Inspired by require(\"ast-types\").NodePath.prototype.needsParens, but\n// more efficient because we're iterating backwards through a stack.\n\n\nFPp.needsParens = function (assumeExpressionContext) {\n  var node = this.getNode(); // This needs to come before `if (!parent) { return false }` because\n  // an object destructuring assignment requires parens for\n  // correctness even when it's the topmost expression.\n\n  if (node.type === \"AssignmentExpression\" && node.left.type === \"ObjectPattern\") {\n    return true;\n  }\n\n  var parent = this.getParentNode();\n\n  if (!parent) {\n    return false;\n  }\n\n  var name = this.getName(); // If the value of this path is some child of a Node and not a Node\n  // itself, then it doesn't need parentheses. Only Node objects (in fact,\n  // only Expression nodes) need parentheses.\n\n  if (this.getValue() !== node) {\n    return false;\n  } // Only statements don't need parentheses.\n\n\n  if (n.Statement.check(node)) {\n    return false;\n  } // Identifiers never need parentheses.\n\n\n  if (node.type === \"Identifier\") {\n    return false;\n  }\n\n  if (parent.type === \"ParenthesizedExpression\" || node.extra && node.extra.parenthesized) {\n    return false;\n  }\n\n  switch (node.type) {\n    case \"UnaryExpression\":\n    case \"SpreadElement\":\n    case \"SpreadProperty\":\n      return parent.type === \"MemberExpression\" && name === \"object\" && parent.object === node;\n\n    case \"BinaryExpression\":\n    case \"LogicalExpression\":\n      switch (parent.type) {\n        case \"CallExpression\":\n          return name === \"callee\" && parent.callee === node;\n\n        case \"UnaryExpression\":\n        case \"SpreadElement\":\n        case \"SpreadProperty\":\n          return true;\n\n        case \"MemberExpression\":\n          return name === \"object\" && parent.object === node;\n\n        case \"BinaryExpression\":\n        case \"LogicalExpression\":\n          {\n            var po = parent.operator;\n            var pp = PRECEDENCE[po];\n            var no = node.operator;\n            var np = PRECEDENCE[no];\n\n            if (pp > np) {\n              return true;\n            }\n\n            if (pp === np && name === \"right\") {\n              assert_1.default.strictEqual(parent.right, node);\n              return true;\n            }\n\n            break;\n          }\n\n        default:\n          return false;\n      }\n\n      break;\n\n    case \"SequenceExpression\":\n      switch (parent.type) {\n        case \"ReturnStatement\":\n          return false;\n\n        case \"ForStatement\":\n          // Although parentheses wouldn't hurt around sequence expressions in\n          // the head of for loops, traditional style dictates that e.g. i++,\n          // j++ should not be wrapped with parentheses.\n          return false;\n\n        case \"ExpressionStatement\":\n          return name !== \"expression\";\n\n        default:\n          // Otherwise err on the side of overparenthesization, adding\n          // explicit exceptions above if this proves overzealous.\n          return true;\n      }\n\n    case \"IntersectionTypeAnnotation\":\n    case \"UnionTypeAnnotation\":\n      return parent.type === \"NullableTypeAnnotation\";\n\n    case \"Literal\":\n      return parent.type === \"MemberExpression\" && isNumber.check(node.value) && name === \"object\" && parent.object === node;\n    // Babel 6 Literal split\n\n    case \"NumericLiteral\":\n      return parent.type === \"MemberExpression\" && name === \"object\" && parent.object === node;\n\n    case \"YieldExpression\":\n    case \"AwaitExpression\":\n    case \"AssignmentExpression\":\n    case \"ConditionalExpression\":\n      switch (parent.type) {\n        case \"UnaryExpression\":\n        case \"SpreadElement\":\n        case \"SpreadProperty\":\n        case \"BinaryExpression\":\n        case \"LogicalExpression\":\n          return true;\n\n        case \"CallExpression\":\n        case \"NewExpression\":\n          return name === \"callee\" && parent.callee === node;\n\n        case \"ConditionalExpression\":\n          return name === \"test\" && parent.test === node;\n\n        case \"MemberExpression\":\n          return name === \"object\" && parent.object === node;\n\n        default:\n          return false;\n      }\n\n    case \"ArrowFunctionExpression\":\n      if (n.CallExpression.check(parent) && name === \"callee\" && parent.callee === node) {\n        return true;\n      }\n\n      if (n.MemberExpression.check(parent) && name === \"object\" && parent.object === node) {\n        return true;\n      }\n\n      if (n.TSAsExpression && n.TSAsExpression.check(parent) && name === \"expression\" && parent.expression === node) {\n        return true;\n      }\n\n      return isBinary(parent);\n\n    case \"ObjectExpression\":\n      if (parent.type === \"ArrowFunctionExpression\" && name === \"body\" && parent.body === node) {\n        return true;\n      }\n\n      break;\n\n    case \"TSAsExpression\":\n      if (parent.type === \"ArrowFunctionExpression\" && name === \"body\" && parent.body === node && node.expression.type === \"ObjectExpression\") {\n        return true;\n      }\n\n      break;\n\n    case \"CallExpression\":\n      if (name === \"declaration\" && n.ExportDefaultDeclaration.check(parent) && n.FunctionExpression.check(node.callee)) {\n        return true;\n      }\n\n  }\n\n  if (parent.type === \"NewExpression\" && name === \"callee\" && parent.callee === node) {\n    return containsCallExpression(node);\n  }\n\n  if (assumeExpressionContext !== true && !this.canBeFirstInStatement() && this.firstInStatement()) {\n    return true;\n  }\n\n  return false;\n};\n\nfunction isBinary(node) {\n  return n.BinaryExpression.check(node) || n.LogicalExpression.check(node);\n} // @ts-ignore 'isUnaryLike' is declared but its value is never read. [6133]\n\n\nfunction isUnaryLike(node) {\n  return n.UnaryExpression.check(node) || // I considered making SpreadElement and SpreadProperty subtypes of\n  // UnaryExpression, but they're not really Expression nodes.\n  n.SpreadElement && n.SpreadElement.check(node) || n.SpreadProperty && n.SpreadProperty.check(node);\n}\n\nfunction containsCallExpression(node) {\n  if (n.CallExpression.check(node)) {\n    return true;\n  }\n\n  if (isArray.check(node)) {\n    return node.some(containsCallExpression);\n  }\n\n  if (n.Node.check(node)) {\n    return types.someField(node, function (_name, child) {\n      return containsCallExpression(child);\n    });\n  }\n\n  return false;\n}\n\nFPp.canBeFirstInStatement = function () {\n  var node = this.getNode();\n\n  if (n.FunctionExpression.check(node)) {\n    return false;\n  }\n\n  if (n.ObjectExpression.check(node)) {\n    return false;\n  }\n\n  if (n.ClassExpression.check(node)) {\n    return false;\n  }\n\n  return true;\n};\n\nFPp.firstInStatement = function () {\n  var s = this.stack;\n  var parentName, parent;\n  var childName, child;\n\n  for (var i = s.length - 1; i >= 0; i -= 2) {\n    if (n.Node.check(s[i])) {\n      childName = parentName;\n      child = parent;\n      parentName = s[i - 1];\n      parent = s[i];\n    }\n\n    if (!parent || !child) {\n      continue;\n    }\n\n    if (n.BlockStatement.check(parent) && parentName === \"body\" && childName === 0) {\n      assert_1.default.strictEqual(parent.body[0], child);\n      return true;\n    }\n\n    if (n.ExpressionStatement.check(parent) && childName === \"expression\") {\n      assert_1.default.strictEqual(parent.expression, child);\n      return true;\n    }\n\n    if (n.AssignmentExpression.check(parent) && childName === \"left\") {\n      assert_1.default.strictEqual(parent.left, child);\n      return true;\n    }\n\n    if (n.ArrowFunctionExpression.check(parent) && childName === \"body\") {\n      assert_1.default.strictEqual(parent.body, child);\n      return true;\n    }\n\n    if (n.SequenceExpression.check(parent) && parentName === \"expressions\" && childName === 0) {\n      assert_1.default.strictEqual(parent.expressions[0], child);\n      continue;\n    }\n\n    if (n.CallExpression.check(parent) && childName === \"callee\") {\n      assert_1.default.strictEqual(parent.callee, child);\n      continue;\n    }\n\n    if (n.MemberExpression.check(parent) && childName === \"object\") {\n      assert_1.default.strictEqual(parent.object, child);\n      continue;\n    }\n\n    if (n.ConditionalExpression.check(parent) && childName === \"test\") {\n      assert_1.default.strictEqual(parent.test, child);\n      continue;\n    }\n\n    if (isBinary(parent) && childName === \"left\") {\n      assert_1.default.strictEqual(parent.left, child);\n      continue;\n    }\n\n    if (n.UnaryExpression.check(parent) && !parent.prefix && childName === \"argument\") {\n      assert_1.default.strictEqual(parent.argument, child);\n      continue;\n    }\n\n    return false;\n  }\n\n  return true;\n};\n\nexports.default = FastPath;","map":{"version":3,"names":["Object","defineProperty","exports","value","tslib_1","require","assert_1","__importDefault","types","__importStar","util","n","namedTypes","isArray","builtInTypes","array","isNumber","number","PRECEDENCE","forEach","tier","i","op","FastPath","default","ok","stack","FPp","prototype","from","obj","copy","NodePath","create","pp","parentPath","push","name","reverse","slice","getName","s","len","length","getValue","valueIsDuplicate","valueIndex","lastIndexOf","getNodeHelper","path","count","Node","check","getNode","getParentNode","getRootValue","call","callback","origLen","argc","arguments","result","each","map","Array","hasParens","node","prevToken","getPrevToken","nextToken","getNextToken","justNeedsOpeningParen","canBeFirstInStatement","firstInStatement","needsParens","loc","tokens","start","token","rootLoc","comparePos","end","assumeExpressionContext","type","left","parent","Statement","extra","parenthesized","object","callee","po","operator","no","np","strictEqual","right","test","CallExpression","MemberExpression","TSAsExpression","expression","isBinary","body","ExportDefaultDeclaration","FunctionExpression","containsCallExpression","BinaryExpression","LogicalExpression","isUnaryLike","UnaryExpression","SpreadElement","SpreadProperty","some","someField","_name","child","ObjectExpression","ClassExpression","parentName","childName","BlockStatement","ExpressionStatement","AssignmentExpression","ArrowFunctionExpression","SequenceExpression","expressions","ConditionalExpression","prefix","argument"],"sources":["/home/haziz1/node_modules/recast/lib/fast-path.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar assert_1 = tslib_1.__importDefault(require(\"assert\"));\nvar types = tslib_1.__importStar(require(\"ast-types\"));\nvar util = tslib_1.__importStar(require(\"./util\"));\nvar n = types.namedTypes;\nvar isArray = types.builtInTypes.array;\nvar isNumber = types.builtInTypes.number;\nvar PRECEDENCE = {};\n[\n    [\"||\"],\n    [\"&&\"],\n    [\"|\"],\n    [\"^\"],\n    [\"&\"],\n    [\"==\", \"===\", \"!=\", \"!==\"],\n    [\"<\", \">\", \"<=\", \">=\", \"in\", \"instanceof\"],\n    [\">>\", \"<<\", \">>>\"],\n    [\"+\", \"-\"],\n    [\"*\", \"/\", \"%\"],\n    [\"**\"],\n].forEach(function (tier, i) {\n    tier.forEach(function (op) {\n        PRECEDENCE[op] = i;\n    });\n});\nvar FastPath = function FastPath(value) {\n    assert_1.default.ok(this instanceof FastPath);\n    this.stack = [value];\n};\nvar FPp = FastPath.prototype;\n// Static convenience function for coercing a value to a FastPath.\nFastPath.from = function (obj) {\n    if (obj instanceof FastPath) {\n        // Return a defensive copy of any existing FastPath instances.\n        return obj.copy();\n    }\n    if (obj instanceof types.NodePath) {\n        // For backwards compatibility, unroll NodePath instances into\n        // lightweight FastPath [..., name, value] stacks.\n        var copy = Object.create(FastPath.prototype);\n        var stack = [obj.value];\n        for (var pp = void 0; (pp = obj.parentPath); obj = pp)\n            stack.push(obj.name, pp.value);\n        copy.stack = stack.reverse();\n        return copy;\n    }\n    // Otherwise use obj as the value of the new FastPath instance.\n    return new FastPath(obj);\n};\nFPp.copy = function copy() {\n    var copy = Object.create(FastPath.prototype);\n    copy.stack = this.stack.slice(0);\n    return copy;\n};\n// The name of the current property is always the penultimate element of\n// this.stack, and always a String.\nFPp.getName = function getName() {\n    var s = this.stack;\n    var len = s.length;\n    if (len > 1) {\n        return s[len - 2];\n    }\n    // Since the name is always a string, null is a safe sentinel value to\n    // return if we do not know the name of the (root) value.\n    return null;\n};\n// The value of the current property is always the final element of\n// this.stack.\nFPp.getValue = function getValue() {\n    var s = this.stack;\n    return s[s.length - 1];\n};\nFPp.valueIsDuplicate = function () {\n    var s = this.stack;\n    var valueIndex = s.length - 1;\n    return s.lastIndexOf(s[valueIndex], valueIndex - 1) >= 0;\n};\nfunction getNodeHelper(path, count) {\n    var s = path.stack;\n    for (var i = s.length - 1; i >= 0; i -= 2) {\n        var value = s[i];\n        if (n.Node.check(value) && --count < 0) {\n            return value;\n        }\n    }\n    return null;\n}\nFPp.getNode = function getNode(count) {\n    if (count === void 0) { count = 0; }\n    return getNodeHelper(this, ~~count);\n};\nFPp.getParentNode = function getParentNode(count) {\n    if (count === void 0) { count = 0; }\n    return getNodeHelper(this, ~~count + 1);\n};\n// The length of the stack can be either even or odd, depending on whether\n// or not we have a name for the root value. The difference between the\n// index of the root value and the index of the final value is always\n// even, though, which allows us to return the root value in constant time\n// (i.e. without iterating backwards through the stack).\nFPp.getRootValue = function getRootValue() {\n    var s = this.stack;\n    if (s.length % 2 === 0) {\n        return s[1];\n    }\n    return s[0];\n};\n// Temporarily push properties named by string arguments given after the\n// callback function onto this.stack, then call the callback with a\n// reference to this (modified) FastPath object. Note that the stack will\n// be restored to its original state after the callback is finished, so it\n// is probably a mistake to retain a reference to the path.\nFPp.call = function call(callback /*, name1, name2, ... */) {\n    var s = this.stack;\n    var origLen = s.length;\n    var value = s[origLen - 1];\n    var argc = arguments.length;\n    for (var i = 1; i < argc; ++i) {\n        var name = arguments[i];\n        value = value[name];\n        s.push(name, value);\n    }\n    var result = callback(this);\n    s.length = origLen;\n    return result;\n};\n// Similar to FastPath.prototype.call, except that the value obtained by\n// accessing this.getValue()[name1][name2]... should be array-like. The\n// callback will be called with a reference to this path object for each\n// element of the array.\nFPp.each = function each(callback /*, name1, name2, ... */) {\n    var s = this.stack;\n    var origLen = s.length;\n    var value = s[origLen - 1];\n    var argc = arguments.length;\n    for (var i = 1; i < argc; ++i) {\n        var name = arguments[i];\n        value = value[name];\n        s.push(name, value);\n    }\n    for (var i = 0; i < value.length; ++i) {\n        if (i in value) {\n            s.push(i, value[i]);\n            // If the callback needs to know the value of i, call\n            // path.getName(), assuming path is the parameter name.\n            callback(this);\n            s.length -= 2;\n        }\n    }\n    s.length = origLen;\n};\n// Similar to FastPath.prototype.each, except that the results of the\n// callback function invocations are stored in an array and returned at\n// the end of the iteration.\nFPp.map = function map(callback /*, name1, name2, ... */) {\n    var s = this.stack;\n    var origLen = s.length;\n    var value = s[origLen - 1];\n    var argc = arguments.length;\n    for (var i = 1; i < argc; ++i) {\n        var name = arguments[i];\n        value = value[name];\n        s.push(name, value);\n    }\n    var result = new Array(value.length);\n    for (var i = 0; i < value.length; ++i) {\n        if (i in value) {\n            s.push(i, value[i]);\n            result[i] = callback(this, i);\n            s.length -= 2;\n        }\n    }\n    s.length = origLen;\n    return result;\n};\n// Returns true if the node at the tip of the path is wrapped with\n// parentheses, OR if the only reason the node needed parentheses was that\n// it couldn't be the first expression in the enclosing statement (see\n// FastPath#canBeFirstInStatement), and it has an opening `(` character.\n// For example, the FunctionExpression in `(function(){}())` appears to\n// need parentheses only because it's the first expression in the AST, but\n// since it happens to be preceded by a `(` (which is not apparent from\n// the AST but can be determined using FastPath#getPrevToken), there is no\n// ambiguity about how to parse it, so it counts as having parentheses,\n// even though it is not immediately followed by a `)`.\nFPp.hasParens = function () {\n    var node = this.getNode();\n    var prevToken = this.getPrevToken(node);\n    if (!prevToken) {\n        return false;\n    }\n    var nextToken = this.getNextToken(node);\n    if (!nextToken) {\n        return false;\n    }\n    if (prevToken.value === \"(\") {\n        if (nextToken.value === \")\") {\n            // If the node preceded by a `(` token and followed by a `)` token,\n            // then of course it has parentheses.\n            return true;\n        }\n        // If this is one of the few Expression types that can't come first in\n        // the enclosing statement because of parsing ambiguities (namely,\n        // FunctionExpression, ObjectExpression, and ClassExpression) and\n        // this.firstInStatement() returns true, and the node would not need\n        // parentheses in an expression context because this.needsParens(true)\n        // returns false, then it just needs an opening parenthesis to resolve\n        // the parsing ambiguity that made it appear to need parentheses.\n        var justNeedsOpeningParen = !this.canBeFirstInStatement() &&\n            this.firstInStatement() &&\n            !this.needsParens(true);\n        if (justNeedsOpeningParen) {\n            return true;\n        }\n    }\n    return false;\n};\nFPp.getPrevToken = function (node) {\n    node = node || this.getNode();\n    var loc = node && node.loc;\n    var tokens = loc && loc.tokens;\n    if (tokens && loc.start.token > 0) {\n        var token = tokens[loc.start.token - 1];\n        if (token) {\n            // Do not return tokens that fall outside the root subtree.\n            var rootLoc = this.getRootValue().loc;\n            if (util.comparePos(rootLoc.start, token.loc.start) <= 0) {\n                return token;\n            }\n        }\n    }\n    return null;\n};\nFPp.getNextToken = function (node) {\n    node = node || this.getNode();\n    var loc = node && node.loc;\n    var tokens = loc && loc.tokens;\n    if (tokens && loc.end.token < tokens.length) {\n        var token = tokens[loc.end.token];\n        if (token) {\n            // Do not return tokens that fall outside the root subtree.\n            var rootLoc = this.getRootValue().loc;\n            if (util.comparePos(token.loc.end, rootLoc.end) <= 0) {\n                return token;\n            }\n        }\n    }\n    return null;\n};\n// Inspired by require(\"ast-types\").NodePath.prototype.needsParens, but\n// more efficient because we're iterating backwards through a stack.\nFPp.needsParens = function (assumeExpressionContext) {\n    var node = this.getNode();\n    // This needs to come before `if (!parent) { return false }` because\n    // an object destructuring assignment requires parens for\n    // correctness even when it's the topmost expression.\n    if (node.type === \"AssignmentExpression\" &&\n        node.left.type === \"ObjectPattern\") {\n        return true;\n    }\n    var parent = this.getParentNode();\n    if (!parent) {\n        return false;\n    }\n    var name = this.getName();\n    // If the value of this path is some child of a Node and not a Node\n    // itself, then it doesn't need parentheses. Only Node objects (in fact,\n    // only Expression nodes) need parentheses.\n    if (this.getValue() !== node) {\n        return false;\n    }\n    // Only statements don't need parentheses.\n    if (n.Statement.check(node)) {\n        return false;\n    }\n    // Identifiers never need parentheses.\n    if (node.type === \"Identifier\") {\n        return false;\n    }\n    if (parent.type === \"ParenthesizedExpression\" ||\n        (node.extra && node.extra.parenthesized)) {\n        return false;\n    }\n    switch (node.type) {\n        case \"UnaryExpression\":\n        case \"SpreadElement\":\n        case \"SpreadProperty\":\n            return (parent.type === \"MemberExpression\" &&\n                name === \"object\" &&\n                parent.object === node);\n        case \"BinaryExpression\":\n        case \"LogicalExpression\":\n            switch (parent.type) {\n                case \"CallExpression\":\n                    return name === \"callee\" && parent.callee === node;\n                case \"UnaryExpression\":\n                case \"SpreadElement\":\n                case \"SpreadProperty\":\n                    return true;\n                case \"MemberExpression\":\n                    return name === \"object\" && parent.object === node;\n                case \"BinaryExpression\":\n                case \"LogicalExpression\": {\n                    var po = parent.operator;\n                    var pp = PRECEDENCE[po];\n                    var no = node.operator;\n                    var np = PRECEDENCE[no];\n                    if (pp > np) {\n                        return true;\n                    }\n                    if (pp === np && name === \"right\") {\n                        assert_1.default.strictEqual(parent.right, node);\n                        return true;\n                    }\n                    break;\n                }\n                default:\n                    return false;\n            }\n            break;\n        case \"SequenceExpression\":\n            switch (parent.type) {\n                case \"ReturnStatement\":\n                    return false;\n                case \"ForStatement\":\n                    // Although parentheses wouldn't hurt around sequence expressions in\n                    // the head of for loops, traditional style dictates that e.g. i++,\n                    // j++ should not be wrapped with parentheses.\n                    return false;\n                case \"ExpressionStatement\":\n                    return name !== \"expression\";\n                default:\n                    // Otherwise err on the side of overparenthesization, adding\n                    // explicit exceptions above if this proves overzealous.\n                    return true;\n            }\n        case \"IntersectionTypeAnnotation\":\n        case \"UnionTypeAnnotation\":\n            return parent.type === \"NullableTypeAnnotation\";\n        case \"Literal\":\n            return (parent.type === \"MemberExpression\" &&\n                isNumber.check(node.value) &&\n                name === \"object\" &&\n                parent.object === node);\n        // Babel 6 Literal split\n        case \"NumericLiteral\":\n            return (parent.type === \"MemberExpression\" &&\n                name === \"object\" &&\n                parent.object === node);\n        case \"YieldExpression\":\n        case \"AwaitExpression\":\n        case \"AssignmentExpression\":\n        case \"ConditionalExpression\":\n            switch (parent.type) {\n                case \"UnaryExpression\":\n                case \"SpreadElement\":\n                case \"SpreadProperty\":\n                case \"BinaryExpression\":\n                case \"LogicalExpression\":\n                    return true;\n                case \"CallExpression\":\n                case \"NewExpression\":\n                    return name === \"callee\" && parent.callee === node;\n                case \"ConditionalExpression\":\n                    return name === \"test\" && parent.test === node;\n                case \"MemberExpression\":\n                    return name === \"object\" && parent.object === node;\n                default:\n                    return false;\n            }\n        case \"ArrowFunctionExpression\":\n            if (n.CallExpression.check(parent) &&\n                name === \"callee\" &&\n                parent.callee === node) {\n                return true;\n            }\n            if (n.MemberExpression.check(parent) &&\n                name === \"object\" &&\n                parent.object === node) {\n                return true;\n            }\n            if (n.TSAsExpression &&\n                n.TSAsExpression.check(parent) &&\n                name === \"expression\" &&\n                parent.expression === node) {\n                return true;\n            }\n            return isBinary(parent);\n        case \"ObjectExpression\":\n            if (parent.type === \"ArrowFunctionExpression\" &&\n                name === \"body\" &&\n                parent.body === node) {\n                return true;\n            }\n            break;\n        case \"TSAsExpression\":\n            if (parent.type === \"ArrowFunctionExpression\" &&\n                name === \"body\" &&\n                parent.body === node &&\n                node.expression.type === \"ObjectExpression\") {\n                return true;\n            }\n            break;\n        case \"CallExpression\":\n            if (name === \"declaration\" &&\n                n.ExportDefaultDeclaration.check(parent) &&\n                n.FunctionExpression.check(node.callee)) {\n                return true;\n            }\n    }\n    if (parent.type === \"NewExpression\" &&\n        name === \"callee\" &&\n        parent.callee === node) {\n        return containsCallExpression(node);\n    }\n    if (assumeExpressionContext !== true &&\n        !this.canBeFirstInStatement() &&\n        this.firstInStatement()) {\n        return true;\n    }\n    return false;\n};\nfunction isBinary(node) {\n    return n.BinaryExpression.check(node) || n.LogicalExpression.check(node);\n}\n// @ts-ignore 'isUnaryLike' is declared but its value is never read. [6133]\nfunction isUnaryLike(node) {\n    return (n.UnaryExpression.check(node) ||\n        // I considered making SpreadElement and SpreadProperty subtypes of\n        // UnaryExpression, but they're not really Expression nodes.\n        (n.SpreadElement && n.SpreadElement.check(node)) ||\n        (n.SpreadProperty && n.SpreadProperty.check(node)));\n}\nfunction containsCallExpression(node) {\n    if (n.CallExpression.check(node)) {\n        return true;\n    }\n    if (isArray.check(node)) {\n        return node.some(containsCallExpression);\n    }\n    if (n.Node.check(node)) {\n        return types.someField(node, function (_name, child) {\n            return containsCallExpression(child);\n        });\n    }\n    return false;\n}\nFPp.canBeFirstInStatement = function () {\n    var node = this.getNode();\n    if (n.FunctionExpression.check(node)) {\n        return false;\n    }\n    if (n.ObjectExpression.check(node)) {\n        return false;\n    }\n    if (n.ClassExpression.check(node)) {\n        return false;\n    }\n    return true;\n};\nFPp.firstInStatement = function () {\n    var s = this.stack;\n    var parentName, parent;\n    var childName, child;\n    for (var i = s.length - 1; i >= 0; i -= 2) {\n        if (n.Node.check(s[i])) {\n            childName = parentName;\n            child = parent;\n            parentName = s[i - 1];\n            parent = s[i];\n        }\n        if (!parent || !child) {\n            continue;\n        }\n        if (n.BlockStatement.check(parent) &&\n            parentName === \"body\" &&\n            childName === 0) {\n            assert_1.default.strictEqual(parent.body[0], child);\n            return true;\n        }\n        if (n.ExpressionStatement.check(parent) && childName === \"expression\") {\n            assert_1.default.strictEqual(parent.expression, child);\n            return true;\n        }\n        if (n.AssignmentExpression.check(parent) && childName === \"left\") {\n            assert_1.default.strictEqual(parent.left, child);\n            return true;\n        }\n        if (n.ArrowFunctionExpression.check(parent) && childName === \"body\") {\n            assert_1.default.strictEqual(parent.body, child);\n            return true;\n        }\n        if (n.SequenceExpression.check(parent) &&\n            parentName === \"expressions\" &&\n            childName === 0) {\n            assert_1.default.strictEqual(parent.expressions[0], child);\n            continue;\n        }\n        if (n.CallExpression.check(parent) && childName === \"callee\") {\n            assert_1.default.strictEqual(parent.callee, child);\n            continue;\n        }\n        if (n.MemberExpression.check(parent) && childName === \"object\") {\n            assert_1.default.strictEqual(parent.object, child);\n            continue;\n        }\n        if (n.ConditionalExpression.check(parent) && childName === \"test\") {\n            assert_1.default.strictEqual(parent.test, child);\n            continue;\n        }\n        if (isBinary(parent) && childName === \"left\") {\n            assert_1.default.strictEqual(parent.left, child);\n            continue;\n        }\n        if (n.UnaryExpression.check(parent) &&\n            !parent.prefix &&\n            childName === \"argument\") {\n            assert_1.default.strictEqual(parent.argument, child);\n            continue;\n        }\n        return false;\n    }\n    return true;\n};\nexports.default = FastPath;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}