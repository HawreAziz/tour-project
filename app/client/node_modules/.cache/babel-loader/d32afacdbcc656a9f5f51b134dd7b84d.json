{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.concat = exports.fromString = exports.countSpaces = exports.Lines = void 0;\n\nvar tslib_1 = require(\"tslib\");\n\nvar assert_1 = tslib_1.__importDefault(require(\"assert\"));\n\nvar source_map_1 = tslib_1.__importDefault(require(\"source-map\"));\n\nvar options_1 = require(\"./options\");\n\nvar util_1 = require(\"./util\");\n\nvar mapping_1 = tslib_1.__importDefault(require(\"./mapping\"));\n\nvar Lines =\n/** @class */\nfunction () {\n  function Lines(infos, sourceFileName) {\n    if (sourceFileName === void 0) {\n      sourceFileName = null;\n    }\n\n    this.infos = infos;\n    this.mappings = [];\n    this.cachedSourceMap = null;\n    this.cachedTabWidth = void 0;\n    assert_1.default.ok(infos.length > 0);\n    this.length = infos.length;\n    this.name = sourceFileName || null;\n\n    if (this.name) {\n      this.mappings.push(new mapping_1.default(this, {\n        start: this.firstPos(),\n        end: this.lastPos()\n      }));\n    }\n  }\n\n  Lines.prototype.toString = function (options) {\n    return this.sliceString(this.firstPos(), this.lastPos(), options);\n  };\n\n  Lines.prototype.getSourceMap = function (sourceMapName, sourceRoot) {\n    if (!sourceMapName) {\n      // Although we could make up a name or generate an anonymous\n      // source map, instead we assume that any consumer who does not\n      // provide a name does not actually want a source map.\n      return null;\n    }\n\n    var targetLines = this;\n\n    function updateJSON(json) {\n      json = json || {};\n      json.file = sourceMapName;\n\n      if (sourceRoot) {\n        json.sourceRoot = sourceRoot;\n      }\n\n      return json;\n    }\n\n    if (targetLines.cachedSourceMap) {\n      // Since Lines objects are immutable, we can reuse any source map\n      // that was previously generated. Nevertheless, we return a new\n      // JSON object here to protect the cached source map from outside\n      // modification.\n      return updateJSON(targetLines.cachedSourceMap.toJSON());\n    }\n\n    var smg = new source_map_1.default.SourceMapGenerator(updateJSON());\n    var sourcesToContents = {};\n    targetLines.mappings.forEach(function (mapping) {\n      var sourceCursor = mapping.sourceLines.skipSpaces(mapping.sourceLoc.start) || mapping.sourceLines.lastPos();\n      var targetCursor = targetLines.skipSpaces(mapping.targetLoc.start) || targetLines.lastPos();\n\n      while (util_1.comparePos(sourceCursor, mapping.sourceLoc.end) < 0 && util_1.comparePos(targetCursor, mapping.targetLoc.end) < 0) {\n        var sourceChar = mapping.sourceLines.charAt(sourceCursor);\n        var targetChar = targetLines.charAt(targetCursor);\n        assert_1.default.strictEqual(sourceChar, targetChar);\n        var sourceName = mapping.sourceLines.name; // Add mappings one character at a time for maximum resolution.\n\n        smg.addMapping({\n          source: sourceName,\n          original: {\n            line: sourceCursor.line,\n            column: sourceCursor.column\n          },\n          generated: {\n            line: targetCursor.line,\n            column: targetCursor.column\n          }\n        });\n\n        if (!hasOwn.call(sourcesToContents, sourceName)) {\n          var sourceContent = mapping.sourceLines.toString();\n          smg.setSourceContent(sourceName, sourceContent);\n          sourcesToContents[sourceName] = sourceContent;\n        }\n\n        targetLines.nextPos(targetCursor, true);\n        mapping.sourceLines.nextPos(sourceCursor, true);\n      }\n    });\n    targetLines.cachedSourceMap = smg;\n    return smg.toJSON();\n  };\n\n  Lines.prototype.bootstrapCharAt = function (pos) {\n    assert_1.default.strictEqual(typeof pos, \"object\");\n    assert_1.default.strictEqual(typeof pos.line, \"number\");\n    assert_1.default.strictEqual(typeof pos.column, \"number\");\n    var line = pos.line,\n        column = pos.column,\n        strings = this.toString().split(lineTerminatorSeqExp),\n        string = strings[line - 1];\n    if (typeof string === \"undefined\") return \"\";\n    if (column === string.length && line < strings.length) return \"\\n\";\n    if (column >= string.length) return \"\";\n    return string.charAt(column);\n  };\n\n  Lines.prototype.charAt = function (pos) {\n    assert_1.default.strictEqual(typeof pos, \"object\");\n    assert_1.default.strictEqual(typeof pos.line, \"number\");\n    assert_1.default.strictEqual(typeof pos.column, \"number\");\n    var line = pos.line,\n        column = pos.column,\n        secret = this,\n        infos = secret.infos,\n        info = infos[line - 1],\n        c = column;\n    if (typeof info === \"undefined\" || c < 0) return \"\";\n    var indent = this.getIndentAt(line);\n    if (c < indent) return \" \";\n    c += info.sliceStart - indent;\n    if (c === info.sliceEnd && line < this.length) return \"\\n\";\n    if (c >= info.sliceEnd) return \"\";\n    return info.line.charAt(c);\n  };\n\n  Lines.prototype.stripMargin = function (width, skipFirstLine) {\n    if (width === 0) return this;\n    assert_1.default.ok(width > 0, \"negative margin: \" + width);\n    if (skipFirstLine && this.length === 1) return this;\n    var lines = new Lines(this.infos.map(function (info, i) {\n      if (info.line && (i > 0 || !skipFirstLine)) {\n        info = tslib_1.__assign(tslib_1.__assign({}, info), {\n          indent: Math.max(0, info.indent - width)\n        });\n      }\n\n      return info;\n    }));\n\n    if (this.mappings.length > 0) {\n      var newMappings_1 = lines.mappings;\n      assert_1.default.strictEqual(newMappings_1.length, 0);\n      this.mappings.forEach(function (mapping) {\n        newMappings_1.push(mapping.indent(width, skipFirstLine, true));\n      });\n    }\n\n    return lines;\n  };\n\n  Lines.prototype.indent = function (by) {\n    if (by === 0) {\n      return this;\n    }\n\n    var lines = new Lines(this.infos.map(function (info) {\n      if (info.line && !info.locked) {\n        info = tslib_1.__assign(tslib_1.__assign({}, info), {\n          indent: info.indent + by\n        });\n      }\n\n      return info;\n    }));\n\n    if (this.mappings.length > 0) {\n      var newMappings_2 = lines.mappings;\n      assert_1.default.strictEqual(newMappings_2.length, 0);\n      this.mappings.forEach(function (mapping) {\n        newMappings_2.push(mapping.indent(by));\n      });\n    }\n\n    return lines;\n  };\n\n  Lines.prototype.indentTail = function (by) {\n    if (by === 0) {\n      return this;\n    }\n\n    if (this.length < 2) {\n      return this;\n    }\n\n    var lines = new Lines(this.infos.map(function (info, i) {\n      if (i > 0 && info.line && !info.locked) {\n        info = tslib_1.__assign(tslib_1.__assign({}, info), {\n          indent: info.indent + by\n        });\n      }\n\n      return info;\n    }));\n\n    if (this.mappings.length > 0) {\n      var newMappings_3 = lines.mappings;\n      assert_1.default.strictEqual(newMappings_3.length, 0);\n      this.mappings.forEach(function (mapping) {\n        newMappings_3.push(mapping.indent(by, true));\n      });\n    }\n\n    return lines;\n  };\n\n  Lines.prototype.lockIndentTail = function () {\n    if (this.length < 2) {\n      return this;\n    }\n\n    return new Lines(this.infos.map(function (info, i) {\n      return tslib_1.__assign(tslib_1.__assign({}, info), {\n        locked: i > 0\n      });\n    }));\n  };\n\n  Lines.prototype.getIndentAt = function (line) {\n    assert_1.default.ok(line >= 1, \"no line \" + line + \" (line numbers start from 1)\");\n    return Math.max(this.infos[line - 1].indent, 0);\n  };\n\n  Lines.prototype.guessTabWidth = function () {\n    if (typeof this.cachedTabWidth === \"number\") {\n      return this.cachedTabWidth;\n    }\n\n    var counts = []; // Sparse array.\n\n    var lastIndent = 0;\n\n    for (var line = 1, last = this.length; line <= last; ++line) {\n      var info = this.infos[line - 1];\n      var sliced = info.line.slice(info.sliceStart, info.sliceEnd); // Whitespace-only lines don't tell us much about the likely tab\n      // width of this code.\n\n      if (isOnlyWhitespace(sliced)) {\n        continue;\n      }\n\n      var diff = Math.abs(info.indent - lastIndent);\n      counts[diff] = ~~counts[diff] + 1;\n      lastIndent = info.indent;\n    }\n\n    var maxCount = -1;\n    var result = 2;\n\n    for (var tabWidth = 1; tabWidth < counts.length; tabWidth += 1) {\n      if (hasOwn.call(counts, tabWidth) && counts[tabWidth] > maxCount) {\n        maxCount = counts[tabWidth];\n        result = tabWidth;\n      }\n    }\n\n    return this.cachedTabWidth = result;\n  }; // Determine if the list of lines has a first line that starts with a //\n  // or /* comment. If this is the case, the code may need to be wrapped in\n  // parens to avoid ASI issues.\n\n\n  Lines.prototype.startsWithComment = function () {\n    if (this.infos.length === 0) {\n      return false;\n    }\n\n    var firstLineInfo = this.infos[0],\n        sliceStart = firstLineInfo.sliceStart,\n        sliceEnd = firstLineInfo.sliceEnd,\n        firstLine = firstLineInfo.line.slice(sliceStart, sliceEnd).trim();\n    return firstLine.length === 0 || firstLine.slice(0, 2) === \"//\" || firstLine.slice(0, 2) === \"/*\";\n  };\n\n  Lines.prototype.isOnlyWhitespace = function () {\n    return isOnlyWhitespace(this.toString());\n  };\n\n  Lines.prototype.isPrecededOnlyByWhitespace = function (pos) {\n    var info = this.infos[pos.line - 1];\n    var indent = Math.max(info.indent, 0);\n    var diff = pos.column - indent;\n\n    if (diff <= 0) {\n      // If pos.column does not exceed the indentation amount, then\n      // there must be only whitespace before it.\n      return true;\n    }\n\n    var start = info.sliceStart;\n    var end = Math.min(start + diff, info.sliceEnd);\n    var prefix = info.line.slice(start, end);\n    return isOnlyWhitespace(prefix);\n  };\n\n  Lines.prototype.getLineLength = function (line) {\n    var info = this.infos[line - 1];\n    return this.getIndentAt(line) + info.sliceEnd - info.sliceStart;\n  };\n\n  Lines.prototype.nextPos = function (pos, skipSpaces) {\n    if (skipSpaces === void 0) {\n      skipSpaces = false;\n    }\n\n    var l = Math.max(pos.line, 0),\n        c = Math.max(pos.column, 0);\n\n    if (c < this.getLineLength(l)) {\n      pos.column += 1;\n      return skipSpaces ? !!this.skipSpaces(pos, false, true) : true;\n    }\n\n    if (l < this.length) {\n      pos.line += 1;\n      pos.column = 0;\n      return skipSpaces ? !!this.skipSpaces(pos, false, true) : true;\n    }\n\n    return false;\n  };\n\n  Lines.prototype.prevPos = function (pos, skipSpaces) {\n    if (skipSpaces === void 0) {\n      skipSpaces = false;\n    }\n\n    var l = pos.line,\n        c = pos.column;\n\n    if (c < 1) {\n      l -= 1;\n      if (l < 1) return false;\n      c = this.getLineLength(l);\n    } else {\n      c = Math.min(c - 1, this.getLineLength(l));\n    }\n\n    pos.line = l;\n    pos.column = c;\n    return skipSpaces ? !!this.skipSpaces(pos, true, true) : true;\n  };\n\n  Lines.prototype.firstPos = function () {\n    // Trivial, but provided for completeness.\n    return {\n      line: 1,\n      column: 0\n    };\n  };\n\n  Lines.prototype.lastPos = function () {\n    return {\n      line: this.length,\n      column: this.getLineLength(this.length)\n    };\n  };\n\n  Lines.prototype.skipSpaces = function (pos, backward, modifyInPlace) {\n    if (backward === void 0) {\n      backward = false;\n    }\n\n    if (modifyInPlace === void 0) {\n      modifyInPlace = false;\n    }\n\n    if (pos) {\n      pos = modifyInPlace ? pos : {\n        line: pos.line,\n        column: pos.column\n      };\n    } else if (backward) {\n      pos = this.lastPos();\n    } else {\n      pos = this.firstPos();\n    }\n\n    if (backward) {\n      while (this.prevPos(pos)) {\n        if (!isOnlyWhitespace(this.charAt(pos)) && this.nextPos(pos)) {\n          return pos;\n        }\n      }\n\n      return null;\n    } else {\n      while (isOnlyWhitespace(this.charAt(pos))) {\n        if (!this.nextPos(pos)) {\n          return null;\n        }\n      }\n\n      return pos;\n    }\n  };\n\n  Lines.prototype.trimLeft = function () {\n    var pos = this.skipSpaces(this.firstPos(), false, true);\n    return pos ? this.slice(pos) : emptyLines;\n  };\n\n  Lines.prototype.trimRight = function () {\n    var pos = this.skipSpaces(this.lastPos(), true, true);\n    return pos ? this.slice(this.firstPos(), pos) : emptyLines;\n  };\n\n  Lines.prototype.trim = function () {\n    var start = this.skipSpaces(this.firstPos(), false, true);\n\n    if (start === null) {\n      return emptyLines;\n    }\n\n    var end = this.skipSpaces(this.lastPos(), true, true);\n\n    if (end === null) {\n      return emptyLines;\n    }\n\n    return this.slice(start, end);\n  };\n\n  Lines.prototype.eachPos = function (callback, startPos, skipSpaces) {\n    if (startPos === void 0) {\n      startPos = this.firstPos();\n    }\n\n    if (skipSpaces === void 0) {\n      skipSpaces = false;\n    }\n\n    var pos = this.firstPos();\n\n    if (startPos) {\n      pos.line = startPos.line, pos.column = startPos.column;\n    }\n\n    if (skipSpaces && !this.skipSpaces(pos, false, true)) {\n      return; // Encountered nothing but spaces.\n    }\n\n    do callback.call(this, pos); while (this.nextPos(pos, skipSpaces));\n  };\n\n  Lines.prototype.bootstrapSlice = function (start, end) {\n    var strings = this.toString().split(lineTerminatorSeqExp).slice(start.line - 1, end.line);\n\n    if (strings.length > 0) {\n      strings.push(strings.pop().slice(0, end.column));\n      strings[0] = strings[0].slice(start.column);\n    }\n\n    return fromString(strings.join(\"\\n\"));\n  };\n\n  Lines.prototype.slice = function (start, end) {\n    if (!end) {\n      if (!start) {\n        // The client seems to want a copy of this Lines object, but\n        // Lines objects are immutable, so it's perfectly adequate to\n        // return the same object.\n        return this;\n      } // Slice to the end if no end position was provided.\n\n\n      end = this.lastPos();\n    }\n\n    if (!start) {\n      throw new Error(\"cannot slice with end but not start\");\n    }\n\n    var sliced = this.infos.slice(start.line - 1, end.line);\n\n    if (start.line === end.line) {\n      sliced[0] = sliceInfo(sliced[0], start.column, end.column);\n    } else {\n      assert_1.default.ok(start.line < end.line);\n      sliced[0] = sliceInfo(sliced[0], start.column);\n      sliced.push(sliceInfo(sliced.pop(), 0, end.column));\n    }\n\n    var lines = new Lines(sliced);\n\n    if (this.mappings.length > 0) {\n      var newMappings_4 = lines.mappings;\n      assert_1.default.strictEqual(newMappings_4.length, 0);\n      this.mappings.forEach(function (mapping) {\n        var sliced = mapping.slice(this, start, end);\n\n        if (sliced) {\n          newMappings_4.push(sliced);\n        }\n      }, this);\n    }\n\n    return lines;\n  };\n\n  Lines.prototype.bootstrapSliceString = function (start, end, options) {\n    return this.slice(start, end).toString(options);\n  };\n\n  Lines.prototype.sliceString = function (start, end, options) {\n    if (start === void 0) {\n      start = this.firstPos();\n    }\n\n    if (end === void 0) {\n      end = this.lastPos();\n    }\n\n    var _a = options_1.normalize(options),\n        tabWidth = _a.tabWidth,\n        useTabs = _a.useTabs,\n        reuseWhitespace = _a.reuseWhitespace,\n        lineTerminator = _a.lineTerminator;\n\n    var parts = [];\n\n    for (var line = start.line; line <= end.line; ++line) {\n      var info = this.infos[line - 1];\n\n      if (line === start.line) {\n        if (line === end.line) {\n          info = sliceInfo(info, start.column, end.column);\n        } else {\n          info = sliceInfo(info, start.column);\n        }\n      } else if (line === end.line) {\n        info = sliceInfo(info, 0, end.column);\n      }\n\n      var indent = Math.max(info.indent, 0);\n      var before_1 = info.line.slice(0, info.sliceStart);\n\n      if (reuseWhitespace && isOnlyWhitespace(before_1) && countSpaces(before_1, tabWidth) === indent) {\n        // Reuse original spaces if the indentation is correct.\n        parts.push(info.line.slice(0, info.sliceEnd));\n        continue;\n      }\n\n      var tabs = 0;\n      var spaces = indent;\n\n      if (useTabs) {\n        tabs = Math.floor(indent / tabWidth);\n        spaces -= tabs * tabWidth;\n      }\n\n      var result = \"\";\n\n      if (tabs > 0) {\n        result += new Array(tabs + 1).join(\"\\t\");\n      }\n\n      if (spaces > 0) {\n        result += new Array(spaces + 1).join(\" \");\n      }\n\n      result += info.line.slice(info.sliceStart, info.sliceEnd);\n      parts.push(result);\n    }\n\n    return parts.join(lineTerminator);\n  };\n\n  Lines.prototype.isEmpty = function () {\n    return this.length < 2 && this.getLineLength(1) < 1;\n  };\n\n  Lines.prototype.join = function (elements) {\n    var separator = this;\n    var infos = [];\n    var mappings = [];\n    var prevInfo;\n\n    function appendLines(linesOrNull) {\n      if (linesOrNull === null) {\n        return;\n      }\n\n      if (prevInfo) {\n        var info = linesOrNull.infos[0];\n        var indent = new Array(info.indent + 1).join(\" \");\n        var prevLine_1 = infos.length;\n        var prevColumn_1 = Math.max(prevInfo.indent, 0) + prevInfo.sliceEnd - prevInfo.sliceStart;\n        prevInfo.line = prevInfo.line.slice(0, prevInfo.sliceEnd) + indent + info.line.slice(info.sliceStart, info.sliceEnd); // If any part of a line is indentation-locked, the whole line\n        // will be indentation-locked.\n\n        prevInfo.locked = prevInfo.locked || info.locked;\n        prevInfo.sliceEnd = prevInfo.line.length;\n\n        if (linesOrNull.mappings.length > 0) {\n          linesOrNull.mappings.forEach(function (mapping) {\n            mappings.push(mapping.add(prevLine_1, prevColumn_1));\n          });\n        }\n      } else if (linesOrNull.mappings.length > 0) {\n        mappings.push.apply(mappings, linesOrNull.mappings);\n      }\n\n      linesOrNull.infos.forEach(function (info, i) {\n        if (!prevInfo || i > 0) {\n          prevInfo = tslib_1.__assign({}, info);\n          infos.push(prevInfo);\n        }\n      });\n    }\n\n    function appendWithSeparator(linesOrNull, i) {\n      if (i > 0) appendLines(separator);\n      appendLines(linesOrNull);\n    }\n\n    elements.map(function (elem) {\n      var lines = fromString(elem);\n      if (lines.isEmpty()) return null;\n      return lines;\n    }).forEach(function (linesOrNull, i) {\n      if (separator.isEmpty()) {\n        appendLines(linesOrNull);\n      } else {\n        appendWithSeparator(linesOrNull, i);\n      }\n    });\n    if (infos.length < 1) return emptyLines;\n    var lines = new Lines(infos);\n    lines.mappings = mappings;\n    return lines;\n  };\n\n  Lines.prototype.concat = function () {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    var list = [this];\n    list.push.apply(list, args);\n    assert_1.default.strictEqual(list.length, args.length + 1);\n    return emptyLines.join(list);\n  };\n\n  return Lines;\n}();\n\nexports.Lines = Lines;\nvar fromStringCache = {};\nvar hasOwn = fromStringCache.hasOwnProperty;\nvar maxCacheKeyLen = 10;\n\nfunction countSpaces(spaces, tabWidth) {\n  var count = 0;\n  var len = spaces.length;\n\n  for (var i = 0; i < len; ++i) {\n    switch (spaces.charCodeAt(i)) {\n      case 9:\n        {\n          // '\\t'\n          assert_1.default.strictEqual(typeof tabWidth, \"number\");\n          assert_1.default.ok(tabWidth > 0);\n          var next = Math.ceil(count / tabWidth) * tabWidth;\n\n          if (next === count) {\n            count += tabWidth;\n          } else {\n            count = next;\n          }\n\n          break;\n        }\n\n      case 11: // '\\v'\n\n      case 12: // '\\f'\n\n      case 13: // '\\r'\n\n      case 0xfeff:\n        // zero-width non-breaking space\n        // These characters contribute nothing to indentation.\n        break;\n\n      case 32: // ' '\n\n      default:\n        // Treat all other whitespace like ' '.\n        count += 1;\n        break;\n    }\n  }\n\n  return count;\n}\n\nexports.countSpaces = countSpaces;\nvar leadingSpaceExp = /^\\s*/; // As specified here: http://www.ecma-international.org/ecma-262/6.0/#sec-line-terminators\n\nvar lineTerminatorSeqExp = /\\u000D\\u000A|\\u000D(?!\\u000A)|\\u000A|\\u2028|\\u2029/;\n/**\n * @param {Object} options - Options object that configures printing.\n */\n\nfunction fromString(string, options) {\n  if (string instanceof Lines) return string;\n  string += \"\";\n  var tabWidth = options && options.tabWidth;\n  var tabless = string.indexOf(\"\\t\") < 0;\n  var cacheable = !options && tabless && string.length <= maxCacheKeyLen;\n  assert_1.default.ok(tabWidth || tabless, \"No tab width specified but encountered tabs in string\\n\" + string);\n  if (cacheable && hasOwn.call(fromStringCache, string)) return fromStringCache[string];\n  var lines = new Lines(string.split(lineTerminatorSeqExp).map(function (line) {\n    // TODO: handle null exec result\n    var spaces = leadingSpaceExp.exec(line)[0];\n    return {\n      line: line,\n      indent: countSpaces(spaces, tabWidth),\n      // Boolean indicating whether this line can be reindented.\n      locked: false,\n      sliceStart: spaces.length,\n      sliceEnd: line.length\n    };\n  }), options_1.normalize(options).sourceFileName);\n  if (cacheable) fromStringCache[string] = lines;\n  return lines;\n}\n\nexports.fromString = fromString;\n\nfunction isOnlyWhitespace(string) {\n  return !/\\S/.test(string);\n}\n\nfunction sliceInfo(info, startCol, endCol) {\n  var sliceStart = info.sliceStart;\n  var sliceEnd = info.sliceEnd;\n  var indent = Math.max(info.indent, 0);\n  var lineLength = indent + sliceEnd - sliceStart;\n\n  if (typeof endCol === \"undefined\") {\n    endCol = lineLength;\n  }\n\n  startCol = Math.max(startCol, 0);\n  endCol = Math.min(endCol, lineLength);\n  endCol = Math.max(endCol, startCol);\n\n  if (endCol < indent) {\n    indent = endCol;\n    sliceEnd = sliceStart;\n  } else {\n    sliceEnd -= lineLength - endCol;\n  }\n\n  lineLength = endCol;\n  lineLength -= startCol;\n\n  if (startCol < indent) {\n    indent -= startCol;\n  } else {\n    startCol -= indent;\n    indent = 0;\n    sliceStart += startCol;\n  }\n\n  assert_1.default.ok(indent >= 0);\n  assert_1.default.ok(sliceStart <= sliceEnd);\n  assert_1.default.strictEqual(lineLength, indent + sliceEnd - sliceStart);\n\n  if (info.indent === indent && info.sliceStart === sliceStart && info.sliceEnd === sliceEnd) {\n    return info;\n  }\n\n  return {\n    line: info.line,\n    indent: indent,\n    // A destructive slice always unlocks indentation.\n    locked: false,\n    sliceStart: sliceStart,\n    sliceEnd: sliceEnd\n  };\n}\n\nfunction concat(elements) {\n  return emptyLines.join(elements);\n}\n\nexports.concat = concat; // The emptyLines object needs to be created all the way down here so that\n// Lines.prototype will be fully populated.\n\nvar emptyLines = fromString(\"\");","map":{"version":3,"names":["Object","defineProperty","exports","value","concat","fromString","countSpaces","Lines","tslib_1","require","assert_1","__importDefault","source_map_1","options_1","util_1","mapping_1","infos","sourceFileName","mappings","cachedSourceMap","cachedTabWidth","default","ok","length","name","push","start","firstPos","end","lastPos","prototype","toString","options","sliceString","getSourceMap","sourceMapName","sourceRoot","targetLines","updateJSON","json","file","toJSON","smg","SourceMapGenerator","sourcesToContents","forEach","mapping","sourceCursor","sourceLines","skipSpaces","sourceLoc","targetCursor","targetLoc","comparePos","sourceChar","charAt","targetChar","strictEqual","sourceName","addMapping","source","original","line","column","generated","hasOwn","call","sourceContent","setSourceContent","nextPos","bootstrapCharAt","pos","strings","split","lineTerminatorSeqExp","string","secret","info","c","indent","getIndentAt","sliceStart","sliceEnd","stripMargin","width","skipFirstLine","lines","map","i","__assign","Math","max","newMappings_1","by","locked","newMappings_2","indentTail","newMappings_3","lockIndentTail","guessTabWidth","counts","lastIndent","last","sliced","slice","isOnlyWhitespace","diff","abs","maxCount","result","tabWidth","startsWithComment","firstLineInfo","firstLine","trim","isPrecededOnlyByWhitespace","min","prefix","getLineLength","l","prevPos","backward","modifyInPlace","trimLeft","emptyLines","trimRight","eachPos","callback","startPos","bootstrapSlice","pop","join","Error","sliceInfo","newMappings_4","bootstrapSliceString","_a","normalize","useTabs","reuseWhitespace","lineTerminator","parts","before_1","tabs","spaces","floor","Array","isEmpty","elements","separator","prevInfo","appendLines","linesOrNull","prevLine_1","prevColumn_1","add","apply","appendWithSeparator","elem","args","_i","arguments","list","fromStringCache","hasOwnProperty","maxCacheKeyLen","count","len","charCodeAt","next","ceil","leadingSpaceExp","tabless","indexOf","cacheable","exec","test","startCol","endCol","lineLength"],"sources":["/home/haziz1/node_modules/recast/lib/lines.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.concat = exports.fromString = exports.countSpaces = exports.Lines = void 0;\nvar tslib_1 = require(\"tslib\");\nvar assert_1 = tslib_1.__importDefault(require(\"assert\"));\nvar source_map_1 = tslib_1.__importDefault(require(\"source-map\"));\nvar options_1 = require(\"./options\");\nvar util_1 = require(\"./util\");\nvar mapping_1 = tslib_1.__importDefault(require(\"./mapping\"));\nvar Lines = /** @class */ (function () {\n    function Lines(infos, sourceFileName) {\n        if (sourceFileName === void 0) { sourceFileName = null; }\n        this.infos = infos;\n        this.mappings = [];\n        this.cachedSourceMap = null;\n        this.cachedTabWidth = void 0;\n        assert_1.default.ok(infos.length > 0);\n        this.length = infos.length;\n        this.name = sourceFileName || null;\n        if (this.name) {\n            this.mappings.push(new mapping_1.default(this, {\n                start: this.firstPos(),\n                end: this.lastPos(),\n            }));\n        }\n    }\n    Lines.prototype.toString = function (options) {\n        return this.sliceString(this.firstPos(), this.lastPos(), options);\n    };\n    Lines.prototype.getSourceMap = function (sourceMapName, sourceRoot) {\n        if (!sourceMapName) {\n            // Although we could make up a name or generate an anonymous\n            // source map, instead we assume that any consumer who does not\n            // provide a name does not actually want a source map.\n            return null;\n        }\n        var targetLines = this;\n        function updateJSON(json) {\n            json = json || {};\n            json.file = sourceMapName;\n            if (sourceRoot) {\n                json.sourceRoot = sourceRoot;\n            }\n            return json;\n        }\n        if (targetLines.cachedSourceMap) {\n            // Since Lines objects are immutable, we can reuse any source map\n            // that was previously generated. Nevertheless, we return a new\n            // JSON object here to protect the cached source map from outside\n            // modification.\n            return updateJSON(targetLines.cachedSourceMap.toJSON());\n        }\n        var smg = new source_map_1.default.SourceMapGenerator(updateJSON());\n        var sourcesToContents = {};\n        targetLines.mappings.forEach(function (mapping) {\n            var sourceCursor = mapping.sourceLines.skipSpaces(mapping.sourceLoc.start) ||\n                mapping.sourceLines.lastPos();\n            var targetCursor = targetLines.skipSpaces(mapping.targetLoc.start) ||\n                targetLines.lastPos();\n            while (util_1.comparePos(sourceCursor, mapping.sourceLoc.end) < 0 &&\n                util_1.comparePos(targetCursor, mapping.targetLoc.end) < 0) {\n                var sourceChar = mapping.sourceLines.charAt(sourceCursor);\n                var targetChar = targetLines.charAt(targetCursor);\n                assert_1.default.strictEqual(sourceChar, targetChar);\n                var sourceName = mapping.sourceLines.name;\n                // Add mappings one character at a time for maximum resolution.\n                smg.addMapping({\n                    source: sourceName,\n                    original: { line: sourceCursor.line, column: sourceCursor.column },\n                    generated: { line: targetCursor.line, column: targetCursor.column },\n                });\n                if (!hasOwn.call(sourcesToContents, sourceName)) {\n                    var sourceContent = mapping.sourceLines.toString();\n                    smg.setSourceContent(sourceName, sourceContent);\n                    sourcesToContents[sourceName] = sourceContent;\n                }\n                targetLines.nextPos(targetCursor, true);\n                mapping.sourceLines.nextPos(sourceCursor, true);\n            }\n        });\n        targetLines.cachedSourceMap = smg;\n        return smg.toJSON();\n    };\n    Lines.prototype.bootstrapCharAt = function (pos) {\n        assert_1.default.strictEqual(typeof pos, \"object\");\n        assert_1.default.strictEqual(typeof pos.line, \"number\");\n        assert_1.default.strictEqual(typeof pos.column, \"number\");\n        var line = pos.line, column = pos.column, strings = this.toString().split(lineTerminatorSeqExp), string = strings[line - 1];\n        if (typeof string === \"undefined\")\n            return \"\";\n        if (column === string.length && line < strings.length)\n            return \"\\n\";\n        if (column >= string.length)\n            return \"\";\n        return string.charAt(column);\n    };\n    Lines.prototype.charAt = function (pos) {\n        assert_1.default.strictEqual(typeof pos, \"object\");\n        assert_1.default.strictEqual(typeof pos.line, \"number\");\n        assert_1.default.strictEqual(typeof pos.column, \"number\");\n        var line = pos.line, column = pos.column, secret = this, infos = secret.infos, info = infos[line - 1], c = column;\n        if (typeof info === \"undefined\" || c < 0)\n            return \"\";\n        var indent = this.getIndentAt(line);\n        if (c < indent)\n            return \" \";\n        c += info.sliceStart - indent;\n        if (c === info.sliceEnd && line < this.length)\n            return \"\\n\";\n        if (c >= info.sliceEnd)\n            return \"\";\n        return info.line.charAt(c);\n    };\n    Lines.prototype.stripMargin = function (width, skipFirstLine) {\n        if (width === 0)\n            return this;\n        assert_1.default.ok(width > 0, \"negative margin: \" + width);\n        if (skipFirstLine && this.length === 1)\n            return this;\n        var lines = new Lines(this.infos.map(function (info, i) {\n            if (info.line && (i > 0 || !skipFirstLine)) {\n                info = tslib_1.__assign(tslib_1.__assign({}, info), { indent: Math.max(0, info.indent - width) });\n            }\n            return info;\n        }));\n        if (this.mappings.length > 0) {\n            var newMappings_1 = lines.mappings;\n            assert_1.default.strictEqual(newMappings_1.length, 0);\n            this.mappings.forEach(function (mapping) {\n                newMappings_1.push(mapping.indent(width, skipFirstLine, true));\n            });\n        }\n        return lines;\n    };\n    Lines.prototype.indent = function (by) {\n        if (by === 0) {\n            return this;\n        }\n        var lines = new Lines(this.infos.map(function (info) {\n            if (info.line && !info.locked) {\n                info = tslib_1.__assign(tslib_1.__assign({}, info), { indent: info.indent + by });\n            }\n            return info;\n        }));\n        if (this.mappings.length > 0) {\n            var newMappings_2 = lines.mappings;\n            assert_1.default.strictEqual(newMappings_2.length, 0);\n            this.mappings.forEach(function (mapping) {\n                newMappings_2.push(mapping.indent(by));\n            });\n        }\n        return lines;\n    };\n    Lines.prototype.indentTail = function (by) {\n        if (by === 0) {\n            return this;\n        }\n        if (this.length < 2) {\n            return this;\n        }\n        var lines = new Lines(this.infos.map(function (info, i) {\n            if (i > 0 && info.line && !info.locked) {\n                info = tslib_1.__assign(tslib_1.__assign({}, info), { indent: info.indent + by });\n            }\n            return info;\n        }));\n        if (this.mappings.length > 0) {\n            var newMappings_3 = lines.mappings;\n            assert_1.default.strictEqual(newMappings_3.length, 0);\n            this.mappings.forEach(function (mapping) {\n                newMappings_3.push(mapping.indent(by, true));\n            });\n        }\n        return lines;\n    };\n    Lines.prototype.lockIndentTail = function () {\n        if (this.length < 2) {\n            return this;\n        }\n        return new Lines(this.infos.map(function (info, i) { return (tslib_1.__assign(tslib_1.__assign({}, info), { locked: i > 0 })); }));\n    };\n    Lines.prototype.getIndentAt = function (line) {\n        assert_1.default.ok(line >= 1, \"no line \" + line + \" (line numbers start from 1)\");\n        return Math.max(this.infos[line - 1].indent, 0);\n    };\n    Lines.prototype.guessTabWidth = function () {\n        if (typeof this.cachedTabWidth === \"number\") {\n            return this.cachedTabWidth;\n        }\n        var counts = []; // Sparse array.\n        var lastIndent = 0;\n        for (var line = 1, last = this.length; line <= last; ++line) {\n            var info = this.infos[line - 1];\n            var sliced = info.line.slice(info.sliceStart, info.sliceEnd);\n            // Whitespace-only lines don't tell us much about the likely tab\n            // width of this code.\n            if (isOnlyWhitespace(sliced)) {\n                continue;\n            }\n            var diff = Math.abs(info.indent - lastIndent);\n            counts[diff] = ~~counts[diff] + 1;\n            lastIndent = info.indent;\n        }\n        var maxCount = -1;\n        var result = 2;\n        for (var tabWidth = 1; tabWidth < counts.length; tabWidth += 1) {\n            if (hasOwn.call(counts, tabWidth) && counts[tabWidth] > maxCount) {\n                maxCount = counts[tabWidth];\n                result = tabWidth;\n            }\n        }\n        return (this.cachedTabWidth = result);\n    };\n    // Determine if the list of lines has a first line that starts with a //\n    // or /* comment. If this is the case, the code may need to be wrapped in\n    // parens to avoid ASI issues.\n    Lines.prototype.startsWithComment = function () {\n        if (this.infos.length === 0) {\n            return false;\n        }\n        var firstLineInfo = this.infos[0], sliceStart = firstLineInfo.sliceStart, sliceEnd = firstLineInfo.sliceEnd, firstLine = firstLineInfo.line.slice(sliceStart, sliceEnd).trim();\n        return (firstLine.length === 0 ||\n            firstLine.slice(0, 2) === \"//\" ||\n            firstLine.slice(0, 2) === \"/*\");\n    };\n    Lines.prototype.isOnlyWhitespace = function () {\n        return isOnlyWhitespace(this.toString());\n    };\n    Lines.prototype.isPrecededOnlyByWhitespace = function (pos) {\n        var info = this.infos[pos.line - 1];\n        var indent = Math.max(info.indent, 0);\n        var diff = pos.column - indent;\n        if (diff <= 0) {\n            // If pos.column does not exceed the indentation amount, then\n            // there must be only whitespace before it.\n            return true;\n        }\n        var start = info.sliceStart;\n        var end = Math.min(start + diff, info.sliceEnd);\n        var prefix = info.line.slice(start, end);\n        return isOnlyWhitespace(prefix);\n    };\n    Lines.prototype.getLineLength = function (line) {\n        var info = this.infos[line - 1];\n        return this.getIndentAt(line) + info.sliceEnd - info.sliceStart;\n    };\n    Lines.prototype.nextPos = function (pos, skipSpaces) {\n        if (skipSpaces === void 0) { skipSpaces = false; }\n        var l = Math.max(pos.line, 0), c = Math.max(pos.column, 0);\n        if (c < this.getLineLength(l)) {\n            pos.column += 1;\n            return skipSpaces ? !!this.skipSpaces(pos, false, true) : true;\n        }\n        if (l < this.length) {\n            pos.line += 1;\n            pos.column = 0;\n            return skipSpaces ? !!this.skipSpaces(pos, false, true) : true;\n        }\n        return false;\n    };\n    Lines.prototype.prevPos = function (pos, skipSpaces) {\n        if (skipSpaces === void 0) { skipSpaces = false; }\n        var l = pos.line, c = pos.column;\n        if (c < 1) {\n            l -= 1;\n            if (l < 1)\n                return false;\n            c = this.getLineLength(l);\n        }\n        else {\n            c = Math.min(c - 1, this.getLineLength(l));\n        }\n        pos.line = l;\n        pos.column = c;\n        return skipSpaces ? !!this.skipSpaces(pos, true, true) : true;\n    };\n    Lines.prototype.firstPos = function () {\n        // Trivial, but provided for completeness.\n        return { line: 1, column: 0 };\n    };\n    Lines.prototype.lastPos = function () {\n        return {\n            line: this.length,\n            column: this.getLineLength(this.length),\n        };\n    };\n    Lines.prototype.skipSpaces = function (pos, backward, modifyInPlace) {\n        if (backward === void 0) { backward = false; }\n        if (modifyInPlace === void 0) { modifyInPlace = false; }\n        if (pos) {\n            pos = modifyInPlace\n                ? pos\n                : {\n                    line: pos.line,\n                    column: pos.column,\n                };\n        }\n        else if (backward) {\n            pos = this.lastPos();\n        }\n        else {\n            pos = this.firstPos();\n        }\n        if (backward) {\n            while (this.prevPos(pos)) {\n                if (!isOnlyWhitespace(this.charAt(pos)) && this.nextPos(pos)) {\n                    return pos;\n                }\n            }\n            return null;\n        }\n        else {\n            while (isOnlyWhitespace(this.charAt(pos))) {\n                if (!this.nextPos(pos)) {\n                    return null;\n                }\n            }\n            return pos;\n        }\n    };\n    Lines.prototype.trimLeft = function () {\n        var pos = this.skipSpaces(this.firstPos(), false, true);\n        return pos ? this.slice(pos) : emptyLines;\n    };\n    Lines.prototype.trimRight = function () {\n        var pos = this.skipSpaces(this.lastPos(), true, true);\n        return pos ? this.slice(this.firstPos(), pos) : emptyLines;\n    };\n    Lines.prototype.trim = function () {\n        var start = this.skipSpaces(this.firstPos(), false, true);\n        if (start === null) {\n            return emptyLines;\n        }\n        var end = this.skipSpaces(this.lastPos(), true, true);\n        if (end === null) {\n            return emptyLines;\n        }\n        return this.slice(start, end);\n    };\n    Lines.prototype.eachPos = function (callback, startPos, skipSpaces) {\n        if (startPos === void 0) { startPos = this.firstPos(); }\n        if (skipSpaces === void 0) { skipSpaces = false; }\n        var pos = this.firstPos();\n        if (startPos) {\n            (pos.line = startPos.line), (pos.column = startPos.column);\n        }\n        if (skipSpaces && !this.skipSpaces(pos, false, true)) {\n            return; // Encountered nothing but spaces.\n        }\n        do\n            callback.call(this, pos);\n        while (this.nextPos(pos, skipSpaces));\n    };\n    Lines.prototype.bootstrapSlice = function (start, end) {\n        var strings = this.toString()\n            .split(lineTerminatorSeqExp)\n            .slice(start.line - 1, end.line);\n        if (strings.length > 0) {\n            strings.push(strings.pop().slice(0, end.column));\n            strings[0] = strings[0].slice(start.column);\n        }\n        return fromString(strings.join(\"\\n\"));\n    };\n    Lines.prototype.slice = function (start, end) {\n        if (!end) {\n            if (!start) {\n                // The client seems to want a copy of this Lines object, but\n                // Lines objects are immutable, so it's perfectly adequate to\n                // return the same object.\n                return this;\n            }\n            // Slice to the end if no end position was provided.\n            end = this.lastPos();\n        }\n        if (!start) {\n            throw new Error(\"cannot slice with end but not start\");\n        }\n        var sliced = this.infos.slice(start.line - 1, end.line);\n        if (start.line === end.line) {\n            sliced[0] = sliceInfo(sliced[0], start.column, end.column);\n        }\n        else {\n            assert_1.default.ok(start.line < end.line);\n            sliced[0] = sliceInfo(sliced[0], start.column);\n            sliced.push(sliceInfo(sliced.pop(), 0, end.column));\n        }\n        var lines = new Lines(sliced);\n        if (this.mappings.length > 0) {\n            var newMappings_4 = lines.mappings;\n            assert_1.default.strictEqual(newMappings_4.length, 0);\n            this.mappings.forEach(function (mapping) {\n                var sliced = mapping.slice(this, start, end);\n                if (sliced) {\n                    newMappings_4.push(sliced);\n                }\n            }, this);\n        }\n        return lines;\n    };\n    Lines.prototype.bootstrapSliceString = function (start, end, options) {\n        return this.slice(start, end).toString(options);\n    };\n    Lines.prototype.sliceString = function (start, end, options) {\n        if (start === void 0) { start = this.firstPos(); }\n        if (end === void 0) { end = this.lastPos(); }\n        var _a = options_1.normalize(options), tabWidth = _a.tabWidth, useTabs = _a.useTabs, reuseWhitespace = _a.reuseWhitespace, lineTerminator = _a.lineTerminator;\n        var parts = [];\n        for (var line = start.line; line <= end.line; ++line) {\n            var info = this.infos[line - 1];\n            if (line === start.line) {\n                if (line === end.line) {\n                    info = sliceInfo(info, start.column, end.column);\n                }\n                else {\n                    info = sliceInfo(info, start.column);\n                }\n            }\n            else if (line === end.line) {\n                info = sliceInfo(info, 0, end.column);\n            }\n            var indent = Math.max(info.indent, 0);\n            var before_1 = info.line.slice(0, info.sliceStart);\n            if (reuseWhitespace &&\n                isOnlyWhitespace(before_1) &&\n                countSpaces(before_1, tabWidth) === indent) {\n                // Reuse original spaces if the indentation is correct.\n                parts.push(info.line.slice(0, info.sliceEnd));\n                continue;\n            }\n            var tabs = 0;\n            var spaces = indent;\n            if (useTabs) {\n                tabs = Math.floor(indent / tabWidth);\n                spaces -= tabs * tabWidth;\n            }\n            var result = \"\";\n            if (tabs > 0) {\n                result += new Array(tabs + 1).join(\"\\t\");\n            }\n            if (spaces > 0) {\n                result += new Array(spaces + 1).join(\" \");\n            }\n            result += info.line.slice(info.sliceStart, info.sliceEnd);\n            parts.push(result);\n        }\n        return parts.join(lineTerminator);\n    };\n    Lines.prototype.isEmpty = function () {\n        return this.length < 2 && this.getLineLength(1) < 1;\n    };\n    Lines.prototype.join = function (elements) {\n        var separator = this;\n        var infos = [];\n        var mappings = [];\n        var prevInfo;\n        function appendLines(linesOrNull) {\n            if (linesOrNull === null) {\n                return;\n            }\n            if (prevInfo) {\n                var info = linesOrNull.infos[0];\n                var indent = new Array(info.indent + 1).join(\" \");\n                var prevLine_1 = infos.length;\n                var prevColumn_1 = Math.max(prevInfo.indent, 0) +\n                    prevInfo.sliceEnd -\n                    prevInfo.sliceStart;\n                prevInfo.line =\n                    prevInfo.line.slice(0, prevInfo.sliceEnd) +\n                        indent +\n                        info.line.slice(info.sliceStart, info.sliceEnd);\n                // If any part of a line is indentation-locked, the whole line\n                // will be indentation-locked.\n                prevInfo.locked = prevInfo.locked || info.locked;\n                prevInfo.sliceEnd = prevInfo.line.length;\n                if (linesOrNull.mappings.length > 0) {\n                    linesOrNull.mappings.forEach(function (mapping) {\n                        mappings.push(mapping.add(prevLine_1, prevColumn_1));\n                    });\n                }\n            }\n            else if (linesOrNull.mappings.length > 0) {\n                mappings.push.apply(mappings, linesOrNull.mappings);\n            }\n            linesOrNull.infos.forEach(function (info, i) {\n                if (!prevInfo || i > 0) {\n                    prevInfo = tslib_1.__assign({}, info);\n                    infos.push(prevInfo);\n                }\n            });\n        }\n        function appendWithSeparator(linesOrNull, i) {\n            if (i > 0)\n                appendLines(separator);\n            appendLines(linesOrNull);\n        }\n        elements\n            .map(function (elem) {\n            var lines = fromString(elem);\n            if (lines.isEmpty())\n                return null;\n            return lines;\n        })\n            .forEach(function (linesOrNull, i) {\n            if (separator.isEmpty()) {\n                appendLines(linesOrNull);\n            }\n            else {\n                appendWithSeparator(linesOrNull, i);\n            }\n        });\n        if (infos.length < 1)\n            return emptyLines;\n        var lines = new Lines(infos);\n        lines.mappings = mappings;\n        return lines;\n    };\n    Lines.prototype.concat = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        var list = [this];\n        list.push.apply(list, args);\n        assert_1.default.strictEqual(list.length, args.length + 1);\n        return emptyLines.join(list);\n    };\n    return Lines;\n}());\nexports.Lines = Lines;\nvar fromStringCache = {};\nvar hasOwn = fromStringCache.hasOwnProperty;\nvar maxCacheKeyLen = 10;\nfunction countSpaces(spaces, tabWidth) {\n    var count = 0;\n    var len = spaces.length;\n    for (var i = 0; i < len; ++i) {\n        switch (spaces.charCodeAt(i)) {\n            case 9: {\n                // '\\t'\n                assert_1.default.strictEqual(typeof tabWidth, \"number\");\n                assert_1.default.ok(tabWidth > 0);\n                var next = Math.ceil(count / tabWidth) * tabWidth;\n                if (next === count) {\n                    count += tabWidth;\n                }\n                else {\n                    count = next;\n                }\n                break;\n            }\n            case 11: // '\\v'\n            case 12: // '\\f'\n            case 13: // '\\r'\n            case 0xfeff: // zero-width non-breaking space\n                // These characters contribute nothing to indentation.\n                break;\n            case 32: // ' '\n            default:\n                // Treat all other whitespace like ' '.\n                count += 1;\n                break;\n        }\n    }\n    return count;\n}\nexports.countSpaces = countSpaces;\nvar leadingSpaceExp = /^\\s*/;\n// As specified here: http://www.ecma-international.org/ecma-262/6.0/#sec-line-terminators\nvar lineTerminatorSeqExp = /\\u000D\\u000A|\\u000D(?!\\u000A)|\\u000A|\\u2028|\\u2029/;\n/**\n * @param {Object} options - Options object that configures printing.\n */\nfunction fromString(string, options) {\n    if (string instanceof Lines)\n        return string;\n    string += \"\";\n    var tabWidth = options && options.tabWidth;\n    var tabless = string.indexOf(\"\\t\") < 0;\n    var cacheable = !options && tabless && string.length <= maxCacheKeyLen;\n    assert_1.default.ok(tabWidth || tabless, \"No tab width specified but encountered tabs in string\\n\" + string);\n    if (cacheable && hasOwn.call(fromStringCache, string))\n        return fromStringCache[string];\n    var lines = new Lines(string.split(lineTerminatorSeqExp).map(function (line) {\n        // TODO: handle null exec result\n        var spaces = leadingSpaceExp.exec(line)[0];\n        return {\n            line: line,\n            indent: countSpaces(spaces, tabWidth),\n            // Boolean indicating whether this line can be reindented.\n            locked: false,\n            sliceStart: spaces.length,\n            sliceEnd: line.length,\n        };\n    }), options_1.normalize(options).sourceFileName);\n    if (cacheable)\n        fromStringCache[string] = lines;\n    return lines;\n}\nexports.fromString = fromString;\nfunction isOnlyWhitespace(string) {\n    return !/\\S/.test(string);\n}\nfunction sliceInfo(info, startCol, endCol) {\n    var sliceStart = info.sliceStart;\n    var sliceEnd = info.sliceEnd;\n    var indent = Math.max(info.indent, 0);\n    var lineLength = indent + sliceEnd - sliceStart;\n    if (typeof endCol === \"undefined\") {\n        endCol = lineLength;\n    }\n    startCol = Math.max(startCol, 0);\n    endCol = Math.min(endCol, lineLength);\n    endCol = Math.max(endCol, startCol);\n    if (endCol < indent) {\n        indent = endCol;\n        sliceEnd = sliceStart;\n    }\n    else {\n        sliceEnd -= lineLength - endCol;\n    }\n    lineLength = endCol;\n    lineLength -= startCol;\n    if (startCol < indent) {\n        indent -= startCol;\n    }\n    else {\n        startCol -= indent;\n        indent = 0;\n        sliceStart += startCol;\n    }\n    assert_1.default.ok(indent >= 0);\n    assert_1.default.ok(sliceStart <= sliceEnd);\n    assert_1.default.strictEqual(lineLength, indent + sliceEnd - sliceStart);\n    if (info.indent === indent &&\n        info.sliceStart === sliceStart &&\n        info.sliceEnd === sliceEnd) {\n        return info;\n    }\n    return {\n        line: info.line,\n        indent: indent,\n        // A destructive slice always unlocks indentation.\n        locked: false,\n        sliceStart: sliceStart,\n        sliceEnd: sliceEnd,\n    };\n}\nfunction concat(elements) {\n    return emptyLines.join(elements);\n}\nexports.concat = concat;\n// The emptyLines object needs to be created all the way down here so that\n// Lines.prototype will be fully populated.\nvar emptyLines = fromString(\"\");\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}