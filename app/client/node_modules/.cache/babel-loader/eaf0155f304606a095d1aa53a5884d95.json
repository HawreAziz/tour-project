{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getReprinter = exports.Patcher = void 0;\n\nvar tslib_1 = require(\"tslib\");\n\nvar assert_1 = tslib_1.__importDefault(require(\"assert\"));\n\nvar linesModule = tslib_1.__importStar(require(\"./lines\"));\n\nvar types = tslib_1.__importStar(require(\"ast-types\"));\n\nvar Printable = types.namedTypes.Printable;\nvar Expression = types.namedTypes.Expression;\nvar ReturnStatement = types.namedTypes.ReturnStatement;\nvar SourceLocation = types.namedTypes.SourceLocation;\n\nvar util_1 = require(\"./util\");\n\nvar fast_path_1 = tslib_1.__importDefault(require(\"./fast-path\"));\n\nvar isObject = types.builtInTypes.object;\nvar isArray = types.builtInTypes.array;\nvar isString = types.builtInTypes.string;\nvar riskyAdjoiningCharExp = /[0-9a-z_$]/i;\n\nvar Patcher = function Patcher(lines) {\n  assert_1.default.ok(this instanceof Patcher);\n  assert_1.default.ok(lines instanceof linesModule.Lines);\n  var self = this,\n      replacements = [];\n\n  self.replace = function (loc, lines) {\n    if (isString.check(lines)) lines = linesModule.fromString(lines);\n    replacements.push({\n      lines: lines,\n      start: loc.start,\n      end: loc.end\n    });\n  };\n\n  self.get = function (loc) {\n    // If no location is provided, return the complete Lines object.\n    loc = loc || {\n      start: {\n        line: 1,\n        column: 0\n      },\n      end: {\n        line: lines.length,\n        column: lines.getLineLength(lines.length)\n      }\n    };\n    var sliceFrom = loc.start,\n        toConcat = [];\n\n    function pushSlice(from, to) {\n      assert_1.default.ok(util_1.comparePos(from, to) <= 0);\n      toConcat.push(lines.slice(from, to));\n    }\n\n    replacements.sort(function (a, b) {\n      return util_1.comparePos(a.start, b.start);\n    }).forEach(function (rep) {\n      if (util_1.comparePos(sliceFrom, rep.start) > 0) {// Ignore nested replacement ranges.\n      } else {\n        pushSlice(sliceFrom, rep.start);\n        toConcat.push(rep.lines);\n        sliceFrom = rep.end;\n      }\n    });\n    pushSlice(sliceFrom, loc.end);\n    return linesModule.concat(toConcat);\n  };\n};\n\nexports.Patcher = Patcher;\nvar Pp = Patcher.prototype;\n\nPp.tryToReprintComments = function (newNode, oldNode, print) {\n  var patcher = this;\n\n  if (!newNode.comments && !oldNode.comments) {\n    // We were (vacuously) able to reprint all the comments!\n    return true;\n  }\n\n  var newPath = fast_path_1.default.from(newNode);\n  var oldPath = fast_path_1.default.from(oldNode);\n  newPath.stack.push(\"comments\", getSurroundingComments(newNode));\n  oldPath.stack.push(\"comments\", getSurroundingComments(oldNode));\n  var reprints = [];\n  var ableToReprintComments = findArrayReprints(newPath, oldPath, reprints); // No need to pop anything from newPath.stack or oldPath.stack, since\n  // newPath and oldPath are fresh local variables.\n\n  if (ableToReprintComments && reprints.length > 0) {\n    reprints.forEach(function (reprint) {\n      var oldComment = reprint.oldPath.getValue();\n      assert_1.default.ok(oldComment.leading || oldComment.trailing);\n      patcher.replace(oldComment.loc, // Comments can't have .comments, so it doesn't matter whether we\n      // print with comments or without.\n      print(reprint.newPath).indentTail(oldComment.loc.indent));\n    });\n  }\n\n  return ableToReprintComments;\n}; // Get all comments that are either leading or trailing, ignoring any\n// comments that occur inside node.loc. Returns an empty array for nodes\n// with no leading or trailing comments.\n\n\nfunction getSurroundingComments(node) {\n  var result = [];\n\n  if (node.comments && node.comments.length > 0) {\n    node.comments.forEach(function (comment) {\n      if (comment.leading || comment.trailing) {\n        result.push(comment);\n      }\n    });\n  }\n\n  return result;\n}\n\nPp.deleteComments = function (node) {\n  if (!node.comments) {\n    return;\n  }\n\n  var patcher = this;\n  node.comments.forEach(function (comment) {\n    if (comment.leading) {\n      // Delete leading comments along with any trailing whitespace they\n      // might have.\n      patcher.replace({\n        start: comment.loc.start,\n        end: node.loc.lines.skipSpaces(comment.loc.end, false, false)\n      }, \"\");\n    } else if (comment.trailing) {\n      // Delete trailing comments along with any leading whitespace they\n      // might have.\n      patcher.replace({\n        start: node.loc.lines.skipSpaces(comment.loc.start, true, false),\n        end: comment.loc.end\n      }, \"\");\n    }\n  });\n};\n\nfunction getReprinter(path) {\n  assert_1.default.ok(path instanceof fast_path_1.default); // Make sure that this path refers specifically to a Node, rather than\n  // some non-Node subproperty of a Node.\n\n  var node = path.getValue();\n  if (!Printable.check(node)) return;\n  var orig = node.original;\n  var origLoc = orig && orig.loc;\n  var lines = origLoc && origLoc.lines;\n  var reprints = [];\n  if (!lines || !findReprints(path, reprints)) return;\n  return function (print) {\n    var patcher = new Patcher(lines);\n    reprints.forEach(function (reprint) {\n      var newNode = reprint.newPath.getValue();\n      var oldNode = reprint.oldPath.getValue();\n      SourceLocation.assert(oldNode.loc, true);\n      var needToPrintNewPathWithComments = !patcher.tryToReprintComments(newNode, oldNode, print);\n\n      if (needToPrintNewPathWithComments) {\n        // Since we were not able to preserve all leading/trailing\n        // comments, we delete oldNode's comments, print newPath with\n        // comments, and then patch the resulting lines where oldNode used\n        // to be.\n        patcher.deleteComments(oldNode);\n      }\n\n      var newLines = print(reprint.newPath, {\n        includeComments: needToPrintNewPathWithComments,\n        // If the oldNode we're replacing already had parentheses, we may\n        // not need to print the new node with any extra parentheses,\n        // because the existing parentheses will suffice. However, if the\n        // newNode has a different type than the oldNode, let the printer\n        // decide if reprint.newPath needs parentheses, as usual.\n        avoidRootParens: oldNode.type === newNode.type && reprint.oldPath.hasParens()\n      }).indentTail(oldNode.loc.indent);\n      var nls = needsLeadingSpace(lines, oldNode.loc, newLines);\n      var nts = needsTrailingSpace(lines, oldNode.loc, newLines); // If we try to replace the argument of a ReturnStatement like\n      // return\"asdf\" with e.g. a literal null expression, we run the risk\n      // of ending up with returnnull, so we need to add an extra leading\n      // space in situations where that might happen. Likewise for\n      // \"asdf\"in obj. See #170.\n\n      if (nls || nts) {\n        var newParts = [];\n        nls && newParts.push(\" \");\n        newParts.push(newLines);\n        nts && newParts.push(\" \");\n        newLines = linesModule.concat(newParts);\n      }\n\n      patcher.replace(oldNode.loc, newLines);\n    }); // Recall that origLoc is the .loc of an ancestor node that is\n    // guaranteed to contain all the reprinted nodes and comments.\n\n    var patchedLines = patcher.get(origLoc).indentTail(-orig.loc.indent);\n\n    if (path.needsParens()) {\n      return linesModule.concat([\"(\", patchedLines, \")\"]);\n    }\n\n    return patchedLines;\n  };\n}\n\nexports.getReprinter = getReprinter; // If the last character before oldLoc and the first character of newLines\n// are both identifier characters, they must be separated by a space,\n// otherwise they will most likely get fused together into a single token.\n\nfunction needsLeadingSpace(oldLines, oldLoc, newLines) {\n  var posBeforeOldLoc = util_1.copyPos(oldLoc.start); // The character just before the location occupied by oldNode.\n\n  var charBeforeOldLoc = oldLines.prevPos(posBeforeOldLoc) && oldLines.charAt(posBeforeOldLoc); // First character of the reprinted node.\n\n  var newFirstChar = newLines.charAt(newLines.firstPos());\n  return charBeforeOldLoc && riskyAdjoiningCharExp.test(charBeforeOldLoc) && newFirstChar && riskyAdjoiningCharExp.test(newFirstChar);\n} // If the last character of newLines and the first character after oldLoc\n// are both identifier characters, they must be separated by a space,\n// otherwise they will most likely get fused together into a single token.\n\n\nfunction needsTrailingSpace(oldLines, oldLoc, newLines) {\n  // The character just after the location occupied by oldNode.\n  var charAfterOldLoc = oldLines.charAt(oldLoc.end);\n  var newLastPos = newLines.lastPos(); // Last character of the reprinted node.\n\n  var newLastChar = newLines.prevPos(newLastPos) && newLines.charAt(newLastPos);\n  return newLastChar && riskyAdjoiningCharExp.test(newLastChar) && charAfterOldLoc && riskyAdjoiningCharExp.test(charAfterOldLoc);\n}\n\nfunction findReprints(newPath, reprints) {\n  var newNode = newPath.getValue();\n  Printable.assert(newNode);\n  var oldNode = newNode.original;\n  Printable.assert(oldNode);\n  assert_1.default.deepEqual(reprints, []);\n\n  if (newNode.type !== oldNode.type) {\n    return false;\n  }\n\n  var oldPath = new fast_path_1.default(oldNode);\n  var canReprint = findChildReprints(newPath, oldPath, reprints);\n\n  if (!canReprint) {\n    // Make absolutely sure the calling code does not attempt to reprint\n    // any nodes.\n    reprints.length = 0;\n  }\n\n  return canReprint;\n}\n\nfunction findAnyReprints(newPath, oldPath, reprints) {\n  var newNode = newPath.getValue();\n  var oldNode = oldPath.getValue();\n  if (newNode === oldNode) return true;\n  if (isArray.check(newNode)) return findArrayReprints(newPath, oldPath, reprints);\n  if (isObject.check(newNode)) return findObjectReprints(newPath, oldPath, reprints);\n  return false;\n}\n\nfunction findArrayReprints(newPath, oldPath, reprints) {\n  var newNode = newPath.getValue();\n  var oldNode = oldPath.getValue();\n\n  if (newNode === oldNode || newPath.valueIsDuplicate() || oldPath.valueIsDuplicate()) {\n    return true;\n  }\n\n  isArray.assert(newNode);\n  var len = newNode.length;\n  if (!(isArray.check(oldNode) && oldNode.length === len)) return false;\n\n  for (var i = 0; i < len; ++i) {\n    newPath.stack.push(i, newNode[i]);\n    oldPath.stack.push(i, oldNode[i]);\n    var canReprint = findAnyReprints(newPath, oldPath, reprints);\n    newPath.stack.length -= 2;\n    oldPath.stack.length -= 2;\n\n    if (!canReprint) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction findObjectReprints(newPath, oldPath, reprints) {\n  var newNode = newPath.getValue();\n  isObject.assert(newNode);\n\n  if (newNode.original === null) {\n    // If newNode.original node was set to null, reprint the node.\n    return false;\n  }\n\n  var oldNode = oldPath.getValue();\n  if (!isObject.check(oldNode)) return false;\n\n  if (newNode === oldNode || newPath.valueIsDuplicate() || oldPath.valueIsDuplicate()) {\n    return true;\n  }\n\n  if (Printable.check(newNode)) {\n    if (!Printable.check(oldNode)) {\n      return false;\n    }\n\n    var newParentNode = newPath.getParentNode();\n    var oldParentNode = oldPath.getParentNode();\n\n    if (oldParentNode !== null && oldParentNode.type === \"FunctionTypeAnnotation\" && newParentNode !== null && newParentNode.type === \"FunctionTypeAnnotation\") {\n      var oldNeedsParens = oldParentNode.params.length !== 1 || !!oldParentNode.params[0].name;\n      var newNeedParens = newParentNode.params.length !== 1 || !!newParentNode.params[0].name;\n\n      if (!oldNeedsParens && newNeedParens) {\n        return false;\n      }\n    } // Here we need to decide whether the reprinted code for newNode is\n    // appropriate for patching into the location of oldNode.\n\n\n    if (newNode.type === oldNode.type) {\n      var childReprints = [];\n\n      if (findChildReprints(newPath, oldPath, childReprints)) {\n        reprints.push.apply(reprints, childReprints);\n      } else if (oldNode.loc) {\n        // If we have no .loc information for oldNode, then we won't be\n        // able to reprint it.\n        reprints.push({\n          oldPath: oldPath.copy(),\n          newPath: newPath.copy()\n        });\n      } else {\n        return false;\n      }\n\n      return true;\n    }\n\n    if (Expression.check(newNode) && Expression.check(oldNode) && // If we have no .loc information for oldNode, then we won't be\n    // able to reprint it.\n    oldNode.loc) {\n      // If both nodes are subtypes of Expression, then we should be able\n      // to fill the location occupied by the old node with code printed\n      // for the new node with no ill consequences.\n      reprints.push({\n        oldPath: oldPath.copy(),\n        newPath: newPath.copy()\n      });\n      return true;\n    } // The nodes have different types, and at least one of the types is\n    // not a subtype of the Expression type, so we cannot safely assume\n    // the nodes are syntactically interchangeable.\n\n\n    return false;\n  }\n\n  return findChildReprints(newPath, oldPath, reprints);\n}\n\nfunction findChildReprints(newPath, oldPath, reprints) {\n  var newNode = newPath.getValue();\n  var oldNode = oldPath.getValue();\n  isObject.assert(newNode);\n  isObject.assert(oldNode);\n\n  if (newNode.original === null) {\n    // If newNode.original node was set to null, reprint the node.\n    return false;\n  } // If this node needs parentheses and will not be wrapped with\n  // parentheses when reprinted, then return false to skip reprinting and\n  // let it be printed generically.\n\n\n  if (newPath.needsParens() && !oldPath.hasParens()) {\n    return false;\n  }\n\n  var keys = util_1.getUnionOfKeys(oldNode, newNode);\n\n  if (oldNode.type === \"File\" || newNode.type === \"File\") {\n    // Don't bother traversing file.tokens, an often very large array\n    // returned by Babylon, and useless for our purposes.\n    delete keys.tokens;\n  } // Don't bother traversing .loc objects looking for reprintable nodes.\n\n\n  delete keys.loc;\n  var originalReprintCount = reprints.length;\n\n  for (var k in keys) {\n    if (k.charAt(0) === \"_\") {\n      // Ignore \"private\" AST properties added by e.g. Babel plugins and\n      // parsers like Babylon.\n      continue;\n    }\n\n    newPath.stack.push(k, types.getFieldValue(newNode, k));\n    oldPath.stack.push(k, types.getFieldValue(oldNode, k));\n    var canReprint = findAnyReprints(newPath, oldPath, reprints);\n    newPath.stack.length -= 2;\n    oldPath.stack.length -= 2;\n\n    if (!canReprint) {\n      return false;\n    }\n  } // Return statements might end up running into ASI issues due to\n  // comments inserted deep within the tree, so reprint them if anything\n  // changed within them.\n\n\n  if (ReturnStatement.check(newPath.getNode()) && reprints.length > originalReprintCount) {\n    return false;\n  }\n\n  return true;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","getReprinter","Patcher","tslib_1","require","assert_1","__importDefault","linesModule","__importStar","types","Printable","namedTypes","Expression","ReturnStatement","SourceLocation","util_1","fast_path_1","isObject","builtInTypes","object","isArray","array","isString","string","riskyAdjoiningCharExp","lines","default","ok","Lines","self","replacements","replace","loc","check","fromString","push","start","end","get","line","column","length","getLineLength","sliceFrom","toConcat","pushSlice","from","to","comparePos","slice","sort","a","b","forEach","rep","concat","Pp","prototype","tryToReprintComments","newNode","oldNode","print","patcher","comments","newPath","oldPath","stack","getSurroundingComments","reprints","ableToReprintComments","findArrayReprints","reprint","oldComment","getValue","leading","trailing","indentTail","indent","node","result","comment","deleteComments","skipSpaces","path","orig","original","origLoc","findReprints","assert","needToPrintNewPathWithComments","newLines","includeComments","avoidRootParens","type","hasParens","nls","needsLeadingSpace","nts","needsTrailingSpace","newParts","patchedLines","needsParens","oldLines","oldLoc","posBeforeOldLoc","copyPos","charBeforeOldLoc","prevPos","charAt","newFirstChar","firstPos","test","charAfterOldLoc","newLastPos","lastPos","newLastChar","deepEqual","canReprint","findChildReprints","findAnyReprints","findObjectReprints","valueIsDuplicate","len","i","newParentNode","getParentNode","oldParentNode","oldNeedsParens","params","name","newNeedParens","childReprints","apply","copy","keys","getUnionOfKeys","tokens","originalReprintCount","k","getFieldValue","getNode"],"sources":["/home/haziz1/node_modules/recast/lib/patcher.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getReprinter = exports.Patcher = void 0;\nvar tslib_1 = require(\"tslib\");\nvar assert_1 = tslib_1.__importDefault(require(\"assert\"));\nvar linesModule = tslib_1.__importStar(require(\"./lines\"));\nvar types = tslib_1.__importStar(require(\"ast-types\"));\nvar Printable = types.namedTypes.Printable;\nvar Expression = types.namedTypes.Expression;\nvar ReturnStatement = types.namedTypes.ReturnStatement;\nvar SourceLocation = types.namedTypes.SourceLocation;\nvar util_1 = require(\"./util\");\nvar fast_path_1 = tslib_1.__importDefault(require(\"./fast-path\"));\nvar isObject = types.builtInTypes.object;\nvar isArray = types.builtInTypes.array;\nvar isString = types.builtInTypes.string;\nvar riskyAdjoiningCharExp = /[0-9a-z_$]/i;\nvar Patcher = function Patcher(lines) {\n    assert_1.default.ok(this instanceof Patcher);\n    assert_1.default.ok(lines instanceof linesModule.Lines);\n    var self = this, replacements = [];\n    self.replace = function (loc, lines) {\n        if (isString.check(lines))\n            lines = linesModule.fromString(lines);\n        replacements.push({\n            lines: lines,\n            start: loc.start,\n            end: loc.end,\n        });\n    };\n    self.get = function (loc) {\n        // If no location is provided, return the complete Lines object.\n        loc = loc || {\n            start: { line: 1, column: 0 },\n            end: { line: lines.length, column: lines.getLineLength(lines.length) },\n        };\n        var sliceFrom = loc.start, toConcat = [];\n        function pushSlice(from, to) {\n            assert_1.default.ok(util_1.comparePos(from, to) <= 0);\n            toConcat.push(lines.slice(from, to));\n        }\n        replacements\n            .sort(function (a, b) { return util_1.comparePos(a.start, b.start); })\n            .forEach(function (rep) {\n            if (util_1.comparePos(sliceFrom, rep.start) > 0) {\n                // Ignore nested replacement ranges.\n            }\n            else {\n                pushSlice(sliceFrom, rep.start);\n                toConcat.push(rep.lines);\n                sliceFrom = rep.end;\n            }\n        });\n        pushSlice(sliceFrom, loc.end);\n        return linesModule.concat(toConcat);\n    };\n};\nexports.Patcher = Patcher;\nvar Pp = Patcher.prototype;\nPp.tryToReprintComments = function (newNode, oldNode, print) {\n    var patcher = this;\n    if (!newNode.comments && !oldNode.comments) {\n        // We were (vacuously) able to reprint all the comments!\n        return true;\n    }\n    var newPath = fast_path_1.default.from(newNode);\n    var oldPath = fast_path_1.default.from(oldNode);\n    newPath.stack.push(\"comments\", getSurroundingComments(newNode));\n    oldPath.stack.push(\"comments\", getSurroundingComments(oldNode));\n    var reprints = [];\n    var ableToReprintComments = findArrayReprints(newPath, oldPath, reprints);\n    // No need to pop anything from newPath.stack or oldPath.stack, since\n    // newPath and oldPath are fresh local variables.\n    if (ableToReprintComments && reprints.length > 0) {\n        reprints.forEach(function (reprint) {\n            var oldComment = reprint.oldPath.getValue();\n            assert_1.default.ok(oldComment.leading || oldComment.trailing);\n            patcher.replace(oldComment.loc, \n            // Comments can't have .comments, so it doesn't matter whether we\n            // print with comments or without.\n            print(reprint.newPath).indentTail(oldComment.loc.indent));\n        });\n    }\n    return ableToReprintComments;\n};\n// Get all comments that are either leading or trailing, ignoring any\n// comments that occur inside node.loc. Returns an empty array for nodes\n// with no leading or trailing comments.\nfunction getSurroundingComments(node) {\n    var result = [];\n    if (node.comments && node.comments.length > 0) {\n        node.comments.forEach(function (comment) {\n            if (comment.leading || comment.trailing) {\n                result.push(comment);\n            }\n        });\n    }\n    return result;\n}\nPp.deleteComments = function (node) {\n    if (!node.comments) {\n        return;\n    }\n    var patcher = this;\n    node.comments.forEach(function (comment) {\n        if (comment.leading) {\n            // Delete leading comments along with any trailing whitespace they\n            // might have.\n            patcher.replace({\n                start: comment.loc.start,\n                end: node.loc.lines.skipSpaces(comment.loc.end, false, false),\n            }, \"\");\n        }\n        else if (comment.trailing) {\n            // Delete trailing comments along with any leading whitespace they\n            // might have.\n            patcher.replace({\n                start: node.loc.lines.skipSpaces(comment.loc.start, true, false),\n                end: comment.loc.end,\n            }, \"\");\n        }\n    });\n};\nfunction getReprinter(path) {\n    assert_1.default.ok(path instanceof fast_path_1.default);\n    // Make sure that this path refers specifically to a Node, rather than\n    // some non-Node subproperty of a Node.\n    var node = path.getValue();\n    if (!Printable.check(node))\n        return;\n    var orig = node.original;\n    var origLoc = orig && orig.loc;\n    var lines = origLoc && origLoc.lines;\n    var reprints = [];\n    if (!lines || !findReprints(path, reprints))\n        return;\n    return function (print) {\n        var patcher = new Patcher(lines);\n        reprints.forEach(function (reprint) {\n            var newNode = reprint.newPath.getValue();\n            var oldNode = reprint.oldPath.getValue();\n            SourceLocation.assert(oldNode.loc, true);\n            var needToPrintNewPathWithComments = !patcher.tryToReprintComments(newNode, oldNode, print);\n            if (needToPrintNewPathWithComments) {\n                // Since we were not able to preserve all leading/trailing\n                // comments, we delete oldNode's comments, print newPath with\n                // comments, and then patch the resulting lines where oldNode used\n                // to be.\n                patcher.deleteComments(oldNode);\n            }\n            var newLines = print(reprint.newPath, {\n                includeComments: needToPrintNewPathWithComments,\n                // If the oldNode we're replacing already had parentheses, we may\n                // not need to print the new node with any extra parentheses,\n                // because the existing parentheses will suffice. However, if the\n                // newNode has a different type than the oldNode, let the printer\n                // decide if reprint.newPath needs parentheses, as usual.\n                avoidRootParens: oldNode.type === newNode.type && reprint.oldPath.hasParens(),\n            }).indentTail(oldNode.loc.indent);\n            var nls = needsLeadingSpace(lines, oldNode.loc, newLines);\n            var nts = needsTrailingSpace(lines, oldNode.loc, newLines);\n            // If we try to replace the argument of a ReturnStatement like\n            // return\"asdf\" with e.g. a literal null expression, we run the risk\n            // of ending up with returnnull, so we need to add an extra leading\n            // space in situations where that might happen. Likewise for\n            // \"asdf\"in obj. See #170.\n            if (nls || nts) {\n                var newParts = [];\n                nls && newParts.push(\" \");\n                newParts.push(newLines);\n                nts && newParts.push(\" \");\n                newLines = linesModule.concat(newParts);\n            }\n            patcher.replace(oldNode.loc, newLines);\n        });\n        // Recall that origLoc is the .loc of an ancestor node that is\n        // guaranteed to contain all the reprinted nodes and comments.\n        var patchedLines = patcher.get(origLoc).indentTail(-orig.loc.indent);\n        if (path.needsParens()) {\n            return linesModule.concat([\"(\", patchedLines, \")\"]);\n        }\n        return patchedLines;\n    };\n}\nexports.getReprinter = getReprinter;\n// If the last character before oldLoc and the first character of newLines\n// are both identifier characters, they must be separated by a space,\n// otherwise they will most likely get fused together into a single token.\nfunction needsLeadingSpace(oldLines, oldLoc, newLines) {\n    var posBeforeOldLoc = util_1.copyPos(oldLoc.start);\n    // The character just before the location occupied by oldNode.\n    var charBeforeOldLoc = oldLines.prevPos(posBeforeOldLoc) && oldLines.charAt(posBeforeOldLoc);\n    // First character of the reprinted node.\n    var newFirstChar = newLines.charAt(newLines.firstPos());\n    return (charBeforeOldLoc &&\n        riskyAdjoiningCharExp.test(charBeforeOldLoc) &&\n        newFirstChar &&\n        riskyAdjoiningCharExp.test(newFirstChar));\n}\n// If the last character of newLines and the first character after oldLoc\n// are both identifier characters, they must be separated by a space,\n// otherwise they will most likely get fused together into a single token.\nfunction needsTrailingSpace(oldLines, oldLoc, newLines) {\n    // The character just after the location occupied by oldNode.\n    var charAfterOldLoc = oldLines.charAt(oldLoc.end);\n    var newLastPos = newLines.lastPos();\n    // Last character of the reprinted node.\n    var newLastChar = newLines.prevPos(newLastPos) && newLines.charAt(newLastPos);\n    return (newLastChar &&\n        riskyAdjoiningCharExp.test(newLastChar) &&\n        charAfterOldLoc &&\n        riskyAdjoiningCharExp.test(charAfterOldLoc));\n}\nfunction findReprints(newPath, reprints) {\n    var newNode = newPath.getValue();\n    Printable.assert(newNode);\n    var oldNode = newNode.original;\n    Printable.assert(oldNode);\n    assert_1.default.deepEqual(reprints, []);\n    if (newNode.type !== oldNode.type) {\n        return false;\n    }\n    var oldPath = new fast_path_1.default(oldNode);\n    var canReprint = findChildReprints(newPath, oldPath, reprints);\n    if (!canReprint) {\n        // Make absolutely sure the calling code does not attempt to reprint\n        // any nodes.\n        reprints.length = 0;\n    }\n    return canReprint;\n}\nfunction findAnyReprints(newPath, oldPath, reprints) {\n    var newNode = newPath.getValue();\n    var oldNode = oldPath.getValue();\n    if (newNode === oldNode)\n        return true;\n    if (isArray.check(newNode))\n        return findArrayReprints(newPath, oldPath, reprints);\n    if (isObject.check(newNode))\n        return findObjectReprints(newPath, oldPath, reprints);\n    return false;\n}\nfunction findArrayReprints(newPath, oldPath, reprints) {\n    var newNode = newPath.getValue();\n    var oldNode = oldPath.getValue();\n    if (newNode === oldNode ||\n        newPath.valueIsDuplicate() ||\n        oldPath.valueIsDuplicate()) {\n        return true;\n    }\n    isArray.assert(newNode);\n    var len = newNode.length;\n    if (!(isArray.check(oldNode) && oldNode.length === len))\n        return false;\n    for (var i = 0; i < len; ++i) {\n        newPath.stack.push(i, newNode[i]);\n        oldPath.stack.push(i, oldNode[i]);\n        var canReprint = findAnyReprints(newPath, oldPath, reprints);\n        newPath.stack.length -= 2;\n        oldPath.stack.length -= 2;\n        if (!canReprint) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction findObjectReprints(newPath, oldPath, reprints) {\n    var newNode = newPath.getValue();\n    isObject.assert(newNode);\n    if (newNode.original === null) {\n        // If newNode.original node was set to null, reprint the node.\n        return false;\n    }\n    var oldNode = oldPath.getValue();\n    if (!isObject.check(oldNode))\n        return false;\n    if (newNode === oldNode ||\n        newPath.valueIsDuplicate() ||\n        oldPath.valueIsDuplicate()) {\n        return true;\n    }\n    if (Printable.check(newNode)) {\n        if (!Printable.check(oldNode)) {\n            return false;\n        }\n        var newParentNode = newPath.getParentNode();\n        var oldParentNode = oldPath.getParentNode();\n        if (oldParentNode !== null &&\n            oldParentNode.type === \"FunctionTypeAnnotation\" &&\n            newParentNode !== null &&\n            newParentNode.type === \"FunctionTypeAnnotation\") {\n            var oldNeedsParens = oldParentNode.params.length !== 1 || !!oldParentNode.params[0].name;\n            var newNeedParens = newParentNode.params.length !== 1 || !!newParentNode.params[0].name;\n            if (!oldNeedsParens && newNeedParens) {\n                return false;\n            }\n        }\n        // Here we need to decide whether the reprinted code for newNode is\n        // appropriate for patching into the location of oldNode.\n        if (newNode.type === oldNode.type) {\n            var childReprints = [];\n            if (findChildReprints(newPath, oldPath, childReprints)) {\n                reprints.push.apply(reprints, childReprints);\n            }\n            else if (oldNode.loc) {\n                // If we have no .loc information for oldNode, then we won't be\n                // able to reprint it.\n                reprints.push({\n                    oldPath: oldPath.copy(),\n                    newPath: newPath.copy(),\n                });\n            }\n            else {\n                return false;\n            }\n            return true;\n        }\n        if (Expression.check(newNode) &&\n            Expression.check(oldNode) &&\n            // If we have no .loc information for oldNode, then we won't be\n            // able to reprint it.\n            oldNode.loc) {\n            // If both nodes are subtypes of Expression, then we should be able\n            // to fill the location occupied by the old node with code printed\n            // for the new node with no ill consequences.\n            reprints.push({\n                oldPath: oldPath.copy(),\n                newPath: newPath.copy(),\n            });\n            return true;\n        }\n        // The nodes have different types, and at least one of the types is\n        // not a subtype of the Expression type, so we cannot safely assume\n        // the nodes are syntactically interchangeable.\n        return false;\n    }\n    return findChildReprints(newPath, oldPath, reprints);\n}\nfunction findChildReprints(newPath, oldPath, reprints) {\n    var newNode = newPath.getValue();\n    var oldNode = oldPath.getValue();\n    isObject.assert(newNode);\n    isObject.assert(oldNode);\n    if (newNode.original === null) {\n        // If newNode.original node was set to null, reprint the node.\n        return false;\n    }\n    // If this node needs parentheses and will not be wrapped with\n    // parentheses when reprinted, then return false to skip reprinting and\n    // let it be printed generically.\n    if (newPath.needsParens() && !oldPath.hasParens()) {\n        return false;\n    }\n    var keys = util_1.getUnionOfKeys(oldNode, newNode);\n    if (oldNode.type === \"File\" || newNode.type === \"File\") {\n        // Don't bother traversing file.tokens, an often very large array\n        // returned by Babylon, and useless for our purposes.\n        delete keys.tokens;\n    }\n    // Don't bother traversing .loc objects looking for reprintable nodes.\n    delete keys.loc;\n    var originalReprintCount = reprints.length;\n    for (var k in keys) {\n        if (k.charAt(0) === \"_\") {\n            // Ignore \"private\" AST properties added by e.g. Babel plugins and\n            // parsers like Babylon.\n            continue;\n        }\n        newPath.stack.push(k, types.getFieldValue(newNode, k));\n        oldPath.stack.push(k, types.getFieldValue(oldNode, k));\n        var canReprint = findAnyReprints(newPath, oldPath, reprints);\n        newPath.stack.length -= 2;\n        oldPath.stack.length -= 2;\n        if (!canReprint) {\n            return false;\n        }\n    }\n    // Return statements might end up running into ASI issues due to\n    // comments inserted deep within the tree, so reprint them if anything\n    // changed within them.\n    if (ReturnStatement.check(newPath.getNode()) &&\n        reprints.length > originalReprintCount) {\n        return false;\n    }\n    return true;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}