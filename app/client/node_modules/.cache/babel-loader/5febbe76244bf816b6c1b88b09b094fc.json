{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.printComments = exports.attach = void 0;\n\nvar tslib_1 = require(\"tslib\");\n\nvar assert_1 = tslib_1.__importDefault(require(\"assert\"));\n\nvar types = tslib_1.__importStar(require(\"ast-types\"));\n\nvar n = types.namedTypes;\nvar isArray = types.builtInTypes.array;\nvar isObject = types.builtInTypes.object;\n\nvar lines_1 = require(\"./lines\");\n\nvar util_1 = require(\"./util\");\n\nvar childNodesCache = new WeakMap(); // TODO Move a non-caching implementation of this function into ast-types,\n// and implement a caching wrapper function here.\n\nfunction getSortedChildNodes(node, lines, resultArray) {\n  if (!node) {\n    return resultArray;\n  } // The .loc checks below are sensitive to some of the problems that\n  // are fixed by this utility function. Specifically, if it decides to\n  // set node.loc to null, indicating that the node's .loc information\n  // is unreliable, then we don't want to add node to the resultArray.\n\n\n  util_1.fixFaultyLocations(node, lines);\n\n  if (resultArray) {\n    if (n.Node.check(node) && n.SourceLocation.check(node.loc)) {\n      // This reverse insertion sort almost always takes constant\n      // time because we almost always (maybe always?) append the\n      // nodes in order anyway.\n      var i = resultArray.length - 1;\n\n      for (; i >= 0; --i) {\n        var child = resultArray[i];\n\n        if (child && child.loc && util_1.comparePos(child.loc.end, node.loc.start) <= 0) {\n          break;\n        }\n      }\n\n      resultArray.splice(i + 1, 0, node);\n      return resultArray;\n    }\n  } else {\n    var childNodes = childNodesCache.get(node);\n\n    if (childNodes) {\n      return childNodes;\n    }\n  }\n\n  var names;\n\n  if (isArray.check(node)) {\n    names = Object.keys(node);\n  } else if (isObject.check(node)) {\n    names = types.getFieldNames(node);\n  } else {\n    return resultArray;\n  }\n\n  if (!resultArray) {\n    childNodesCache.set(node, resultArray = []);\n  }\n\n  for (var i = 0, nameCount = names.length; i < nameCount; ++i) {\n    getSortedChildNodes(node[names[i]], lines, resultArray);\n  }\n\n  return resultArray;\n} // As efficiently as possible, decorate the comment object with\n// .precedingNode, .enclosingNode, and/or .followingNode properties, at\n// least one of which is guaranteed to be defined.\n\n\nfunction decorateComment(node, comment, lines) {\n  var childNodes = getSortedChildNodes(node, lines); // Time to dust off the old binary search robes and wizard hat.\n\n  var left = 0;\n  var right = childNodes && childNodes.length;\n  var precedingNode;\n  var followingNode;\n\n  while (typeof right === \"number\" && left < right) {\n    var middle = left + right >> 1;\n    var child = childNodes[middle];\n\n    if (util_1.comparePos(child.loc.start, comment.loc.start) <= 0 && util_1.comparePos(comment.loc.end, child.loc.end) <= 0) {\n      // The comment is completely contained by this child node.\n      decorateComment(comment.enclosingNode = child, comment, lines);\n      return; // Abandon the binary search at this level.\n    }\n\n    if (util_1.comparePos(child.loc.end, comment.loc.start) <= 0) {\n      // This child node falls completely before the comment.\n      // Because we will never consider this node or any nodes\n      // before it again, this node must be the closest preceding\n      // node we have encountered so far.\n      precedingNode = child;\n      left = middle + 1;\n      continue;\n    }\n\n    if (util_1.comparePos(comment.loc.end, child.loc.start) <= 0) {\n      // This child node falls completely after the comment.\n      // Because we will never consider this node or any nodes after\n      // it again, this node must be the closest following node we\n      // have encountered so far.\n      followingNode = child;\n      right = middle;\n      continue;\n    }\n\n    throw new Error(\"Comment location overlaps with node location\");\n  }\n\n  if (precedingNode) {\n    comment.precedingNode = precedingNode;\n  }\n\n  if (followingNode) {\n    comment.followingNode = followingNode;\n  }\n}\n\nfunction attach(comments, ast, lines) {\n  if (!isArray.check(comments)) {\n    return;\n  }\n\n  var tiesToBreak = [];\n  comments.forEach(function (comment) {\n    comment.loc.lines = lines;\n    decorateComment(ast, comment, lines);\n    var pn = comment.precedingNode;\n    var en = comment.enclosingNode;\n    var fn = comment.followingNode;\n\n    if (pn && fn) {\n      var tieCount = tiesToBreak.length;\n\n      if (tieCount > 0) {\n        var lastTie = tiesToBreak[tieCount - 1];\n        assert_1.default.strictEqual(lastTie.precedingNode === comment.precedingNode, lastTie.followingNode === comment.followingNode);\n\n        if (lastTie.followingNode !== comment.followingNode) {\n          breakTies(tiesToBreak, lines);\n        }\n      }\n\n      tiesToBreak.push(comment);\n    } else if (pn) {\n      // No contest: we have a trailing comment.\n      breakTies(tiesToBreak, lines);\n      addTrailingComment(pn, comment);\n    } else if (fn) {\n      // No contest: we have a leading comment.\n      breakTies(tiesToBreak, lines);\n      addLeadingComment(fn, comment);\n    } else if (en) {\n      // The enclosing node has no child nodes at all, so what we\n      // have here is a dangling comment, e.g. [/* crickets */].\n      breakTies(tiesToBreak, lines);\n      addDanglingComment(en, comment);\n    } else {\n      throw new Error(\"AST contains no nodes at all?\");\n    }\n  });\n  breakTies(tiesToBreak, lines);\n  comments.forEach(function (comment) {\n    // These node references were useful for breaking ties, but we\n    // don't need them anymore, and they create cycles in the AST that\n    // may lead to infinite recursion if we don't delete them here.\n    delete comment.precedingNode;\n    delete comment.enclosingNode;\n    delete comment.followingNode;\n  });\n}\n\nexports.attach = attach;\n\nfunction breakTies(tiesToBreak, lines) {\n  var tieCount = tiesToBreak.length;\n\n  if (tieCount === 0) {\n    return;\n  }\n\n  var pn = tiesToBreak[0].precedingNode;\n  var fn = tiesToBreak[0].followingNode;\n  var gapEndPos = fn.loc.start; // Iterate backwards through tiesToBreak, examining the gaps\n  // between the tied comments. In order to qualify as leading, a\n  // comment must be separated from fn by an unbroken series of\n  // whitespace-only gaps (or other comments).\n\n  var indexOfFirstLeadingComment = tieCount;\n  var comment;\n\n  for (; indexOfFirstLeadingComment > 0; --indexOfFirstLeadingComment) {\n    comment = tiesToBreak[indexOfFirstLeadingComment - 1];\n    assert_1.default.strictEqual(comment.precedingNode, pn);\n    assert_1.default.strictEqual(comment.followingNode, fn);\n    var gap = lines.sliceString(comment.loc.end, gapEndPos);\n\n    if (/\\S/.test(gap)) {\n      // The gap string contained something other than whitespace.\n      break;\n    }\n\n    gapEndPos = comment.loc.start;\n  }\n\n  while (indexOfFirstLeadingComment <= tieCount && (comment = tiesToBreak[indexOfFirstLeadingComment]) && ( // If the comment is a //-style comment and indented more\n  // deeply than the node itself, reconsider it as trailing.\n  comment.type === \"Line\" || comment.type === \"CommentLine\") && comment.loc.start.column > fn.loc.start.column) {\n    ++indexOfFirstLeadingComment;\n  }\n\n  tiesToBreak.forEach(function (comment, i) {\n    if (i < indexOfFirstLeadingComment) {\n      addTrailingComment(pn, comment);\n    } else {\n      addLeadingComment(fn, comment);\n    }\n  });\n  tiesToBreak.length = 0;\n}\n\nfunction addCommentHelper(node, comment) {\n  var comments = node.comments || (node.comments = []);\n  comments.push(comment);\n}\n\nfunction addLeadingComment(node, comment) {\n  comment.leading = true;\n  comment.trailing = false;\n  addCommentHelper(node, comment);\n}\n\nfunction addDanglingComment(node, comment) {\n  comment.leading = false;\n  comment.trailing = false;\n  addCommentHelper(node, comment);\n}\n\nfunction addTrailingComment(node, comment) {\n  comment.leading = false;\n  comment.trailing = true;\n  addCommentHelper(node, comment);\n}\n\nfunction printLeadingComment(commentPath, print) {\n  var comment = commentPath.getValue();\n  n.Comment.assert(comment);\n  var loc = comment.loc;\n  var lines = loc && loc.lines;\n  var parts = [print(commentPath)];\n\n  if (comment.trailing) {\n    // When we print trailing comments as leading comments, we don't\n    // want to bring any trailing spaces along.\n    parts.push(\"\\n\");\n  } else if (lines instanceof lines_1.Lines) {\n    var trailingSpace = lines.slice(loc.end, lines.skipSpaces(loc.end) || lines.lastPos());\n\n    if (trailingSpace.length === 1) {\n      // If the trailing space contains no newlines, then we want to\n      // preserve it exactly as we found it.\n      parts.push(trailingSpace);\n    } else {\n      // If the trailing space contains newlines, then replace it\n      // with just that many newlines, with all other spaces removed.\n      parts.push(new Array(trailingSpace.length).join(\"\\n\"));\n    }\n  } else {\n    parts.push(\"\\n\");\n  }\n\n  return lines_1.concat(parts);\n}\n\nfunction printTrailingComment(commentPath, print) {\n  var comment = commentPath.getValue(commentPath);\n  n.Comment.assert(comment);\n  var loc = comment.loc;\n  var lines = loc && loc.lines;\n  var parts = [];\n\n  if (lines instanceof lines_1.Lines) {\n    var fromPos = lines.skipSpaces(loc.start, true) || lines.firstPos();\n    var leadingSpace = lines.slice(fromPos, loc.start);\n\n    if (leadingSpace.length === 1) {\n      // If the leading space contains no newlines, then we want to\n      // preserve it exactly as we found it.\n      parts.push(leadingSpace);\n    } else {\n      // If the leading space contains newlines, then replace it\n      // with just that many newlines, sans all other spaces.\n      parts.push(new Array(leadingSpace.length).join(\"\\n\"));\n    }\n  }\n\n  parts.push(print(commentPath));\n  return lines_1.concat(parts);\n}\n\nfunction printComments(path, print) {\n  var value = path.getValue();\n  var innerLines = print(path);\n  var comments = n.Node.check(value) && types.getFieldValue(value, \"comments\");\n\n  if (!comments || comments.length === 0) {\n    return innerLines;\n  }\n\n  var leadingParts = [];\n  var trailingParts = [innerLines];\n  path.each(function (commentPath) {\n    var comment = commentPath.getValue();\n    var leading = types.getFieldValue(comment, \"leading\");\n    var trailing = types.getFieldValue(comment, \"trailing\");\n\n    if (leading || trailing && !(n.Statement.check(value) || comment.type === \"Block\" || comment.type === \"CommentBlock\")) {\n      leadingParts.push(printLeadingComment(commentPath, print));\n    } else if (trailing) {\n      trailingParts.push(printTrailingComment(commentPath, print));\n    }\n  }, \"comments\");\n  leadingParts.push.apply(leadingParts, trailingParts);\n  return lines_1.concat(leadingParts);\n}\n\nexports.printComments = printComments;","map":{"version":3,"names":["Object","defineProperty","exports","value","printComments","attach","tslib_1","require","assert_1","__importDefault","types","__importStar","n","namedTypes","isArray","builtInTypes","array","isObject","object","lines_1","util_1","childNodesCache","WeakMap","getSortedChildNodes","node","lines","resultArray","fixFaultyLocations","Node","check","SourceLocation","loc","i","length","child","comparePos","end","start","splice","childNodes","get","names","keys","getFieldNames","set","nameCount","decorateComment","comment","left","right","precedingNode","followingNode","middle","enclosingNode","Error","comments","ast","tiesToBreak","forEach","pn","en","fn","tieCount","lastTie","default","strictEqual","breakTies","push","addTrailingComment","addLeadingComment","addDanglingComment","gapEndPos","indexOfFirstLeadingComment","gap","sliceString","test","type","column","addCommentHelper","leading","trailing","printLeadingComment","commentPath","print","getValue","Comment","assert","parts","Lines","trailingSpace","slice","skipSpaces","lastPos","Array","join","concat","printTrailingComment","fromPos","firstPos","leadingSpace","path","innerLines","getFieldValue","leadingParts","trailingParts","each","Statement","apply"],"sources":["/home/haziz1/node_modules/recast/lib/comments.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.printComments = exports.attach = void 0;\nvar tslib_1 = require(\"tslib\");\nvar assert_1 = tslib_1.__importDefault(require(\"assert\"));\nvar types = tslib_1.__importStar(require(\"ast-types\"));\nvar n = types.namedTypes;\nvar isArray = types.builtInTypes.array;\nvar isObject = types.builtInTypes.object;\nvar lines_1 = require(\"./lines\");\nvar util_1 = require(\"./util\");\nvar childNodesCache = new WeakMap();\n// TODO Move a non-caching implementation of this function into ast-types,\n// and implement a caching wrapper function here.\nfunction getSortedChildNodes(node, lines, resultArray) {\n    if (!node) {\n        return resultArray;\n    }\n    // The .loc checks below are sensitive to some of the problems that\n    // are fixed by this utility function. Specifically, if it decides to\n    // set node.loc to null, indicating that the node's .loc information\n    // is unreliable, then we don't want to add node to the resultArray.\n    util_1.fixFaultyLocations(node, lines);\n    if (resultArray) {\n        if (n.Node.check(node) && n.SourceLocation.check(node.loc)) {\n            // This reverse insertion sort almost always takes constant\n            // time because we almost always (maybe always?) append the\n            // nodes in order anyway.\n            var i = resultArray.length - 1;\n            for (; i >= 0; --i) {\n                var child = resultArray[i];\n                if (child &&\n                    child.loc &&\n                    util_1.comparePos(child.loc.end, node.loc.start) <= 0) {\n                    break;\n                }\n            }\n            resultArray.splice(i + 1, 0, node);\n            return resultArray;\n        }\n    }\n    else {\n        var childNodes = childNodesCache.get(node);\n        if (childNodes) {\n            return childNodes;\n        }\n    }\n    var names;\n    if (isArray.check(node)) {\n        names = Object.keys(node);\n    }\n    else if (isObject.check(node)) {\n        names = types.getFieldNames(node);\n    }\n    else {\n        return resultArray;\n    }\n    if (!resultArray) {\n        childNodesCache.set(node, (resultArray = []));\n    }\n    for (var i = 0, nameCount = names.length; i < nameCount; ++i) {\n        getSortedChildNodes(node[names[i]], lines, resultArray);\n    }\n    return resultArray;\n}\n// As efficiently as possible, decorate the comment object with\n// .precedingNode, .enclosingNode, and/or .followingNode properties, at\n// least one of which is guaranteed to be defined.\nfunction decorateComment(node, comment, lines) {\n    var childNodes = getSortedChildNodes(node, lines);\n    // Time to dust off the old binary search robes and wizard hat.\n    var left = 0;\n    var right = childNodes && childNodes.length;\n    var precedingNode;\n    var followingNode;\n    while (typeof right === \"number\" && left < right) {\n        var middle = (left + right) >> 1;\n        var child = childNodes[middle];\n        if (util_1.comparePos(child.loc.start, comment.loc.start) <= 0 &&\n            util_1.comparePos(comment.loc.end, child.loc.end) <= 0) {\n            // The comment is completely contained by this child node.\n            decorateComment((comment.enclosingNode = child), comment, lines);\n            return; // Abandon the binary search at this level.\n        }\n        if (util_1.comparePos(child.loc.end, comment.loc.start) <= 0) {\n            // This child node falls completely before the comment.\n            // Because we will never consider this node or any nodes\n            // before it again, this node must be the closest preceding\n            // node we have encountered so far.\n            precedingNode = child;\n            left = middle + 1;\n            continue;\n        }\n        if (util_1.comparePos(comment.loc.end, child.loc.start) <= 0) {\n            // This child node falls completely after the comment.\n            // Because we will never consider this node or any nodes after\n            // it again, this node must be the closest following node we\n            // have encountered so far.\n            followingNode = child;\n            right = middle;\n            continue;\n        }\n        throw new Error(\"Comment location overlaps with node location\");\n    }\n    if (precedingNode) {\n        comment.precedingNode = precedingNode;\n    }\n    if (followingNode) {\n        comment.followingNode = followingNode;\n    }\n}\nfunction attach(comments, ast, lines) {\n    if (!isArray.check(comments)) {\n        return;\n    }\n    var tiesToBreak = [];\n    comments.forEach(function (comment) {\n        comment.loc.lines = lines;\n        decorateComment(ast, comment, lines);\n        var pn = comment.precedingNode;\n        var en = comment.enclosingNode;\n        var fn = comment.followingNode;\n        if (pn && fn) {\n            var tieCount = tiesToBreak.length;\n            if (tieCount > 0) {\n                var lastTie = tiesToBreak[tieCount - 1];\n                assert_1.default.strictEqual(lastTie.precedingNode === comment.precedingNode, lastTie.followingNode === comment.followingNode);\n                if (lastTie.followingNode !== comment.followingNode) {\n                    breakTies(tiesToBreak, lines);\n                }\n            }\n            tiesToBreak.push(comment);\n        }\n        else if (pn) {\n            // No contest: we have a trailing comment.\n            breakTies(tiesToBreak, lines);\n            addTrailingComment(pn, comment);\n        }\n        else if (fn) {\n            // No contest: we have a leading comment.\n            breakTies(tiesToBreak, lines);\n            addLeadingComment(fn, comment);\n        }\n        else if (en) {\n            // The enclosing node has no child nodes at all, so what we\n            // have here is a dangling comment, e.g. [/* crickets */].\n            breakTies(tiesToBreak, lines);\n            addDanglingComment(en, comment);\n        }\n        else {\n            throw new Error(\"AST contains no nodes at all?\");\n        }\n    });\n    breakTies(tiesToBreak, lines);\n    comments.forEach(function (comment) {\n        // These node references were useful for breaking ties, but we\n        // don't need them anymore, and they create cycles in the AST that\n        // may lead to infinite recursion if we don't delete them here.\n        delete comment.precedingNode;\n        delete comment.enclosingNode;\n        delete comment.followingNode;\n    });\n}\nexports.attach = attach;\nfunction breakTies(tiesToBreak, lines) {\n    var tieCount = tiesToBreak.length;\n    if (tieCount === 0) {\n        return;\n    }\n    var pn = tiesToBreak[0].precedingNode;\n    var fn = tiesToBreak[0].followingNode;\n    var gapEndPos = fn.loc.start;\n    // Iterate backwards through tiesToBreak, examining the gaps\n    // between the tied comments. In order to qualify as leading, a\n    // comment must be separated from fn by an unbroken series of\n    // whitespace-only gaps (or other comments).\n    var indexOfFirstLeadingComment = tieCount;\n    var comment;\n    for (; indexOfFirstLeadingComment > 0; --indexOfFirstLeadingComment) {\n        comment = tiesToBreak[indexOfFirstLeadingComment - 1];\n        assert_1.default.strictEqual(comment.precedingNode, pn);\n        assert_1.default.strictEqual(comment.followingNode, fn);\n        var gap = lines.sliceString(comment.loc.end, gapEndPos);\n        if (/\\S/.test(gap)) {\n            // The gap string contained something other than whitespace.\n            break;\n        }\n        gapEndPos = comment.loc.start;\n    }\n    while (indexOfFirstLeadingComment <= tieCount &&\n        (comment = tiesToBreak[indexOfFirstLeadingComment]) &&\n        // If the comment is a //-style comment and indented more\n        // deeply than the node itself, reconsider it as trailing.\n        (comment.type === \"Line\" || comment.type === \"CommentLine\") &&\n        comment.loc.start.column > fn.loc.start.column) {\n        ++indexOfFirstLeadingComment;\n    }\n    tiesToBreak.forEach(function (comment, i) {\n        if (i < indexOfFirstLeadingComment) {\n            addTrailingComment(pn, comment);\n        }\n        else {\n            addLeadingComment(fn, comment);\n        }\n    });\n    tiesToBreak.length = 0;\n}\nfunction addCommentHelper(node, comment) {\n    var comments = node.comments || (node.comments = []);\n    comments.push(comment);\n}\nfunction addLeadingComment(node, comment) {\n    comment.leading = true;\n    comment.trailing = false;\n    addCommentHelper(node, comment);\n}\nfunction addDanglingComment(node, comment) {\n    comment.leading = false;\n    comment.trailing = false;\n    addCommentHelper(node, comment);\n}\nfunction addTrailingComment(node, comment) {\n    comment.leading = false;\n    comment.trailing = true;\n    addCommentHelper(node, comment);\n}\nfunction printLeadingComment(commentPath, print) {\n    var comment = commentPath.getValue();\n    n.Comment.assert(comment);\n    var loc = comment.loc;\n    var lines = loc && loc.lines;\n    var parts = [print(commentPath)];\n    if (comment.trailing) {\n        // When we print trailing comments as leading comments, we don't\n        // want to bring any trailing spaces along.\n        parts.push(\"\\n\");\n    }\n    else if (lines instanceof lines_1.Lines) {\n        var trailingSpace = lines.slice(loc.end, lines.skipSpaces(loc.end) || lines.lastPos());\n        if (trailingSpace.length === 1) {\n            // If the trailing space contains no newlines, then we want to\n            // preserve it exactly as we found it.\n            parts.push(trailingSpace);\n        }\n        else {\n            // If the trailing space contains newlines, then replace it\n            // with just that many newlines, with all other spaces removed.\n            parts.push(new Array(trailingSpace.length).join(\"\\n\"));\n        }\n    }\n    else {\n        parts.push(\"\\n\");\n    }\n    return lines_1.concat(parts);\n}\nfunction printTrailingComment(commentPath, print) {\n    var comment = commentPath.getValue(commentPath);\n    n.Comment.assert(comment);\n    var loc = comment.loc;\n    var lines = loc && loc.lines;\n    var parts = [];\n    if (lines instanceof lines_1.Lines) {\n        var fromPos = lines.skipSpaces(loc.start, true) || lines.firstPos();\n        var leadingSpace = lines.slice(fromPos, loc.start);\n        if (leadingSpace.length === 1) {\n            // If the leading space contains no newlines, then we want to\n            // preserve it exactly as we found it.\n            parts.push(leadingSpace);\n        }\n        else {\n            // If the leading space contains newlines, then replace it\n            // with just that many newlines, sans all other spaces.\n            parts.push(new Array(leadingSpace.length).join(\"\\n\"));\n        }\n    }\n    parts.push(print(commentPath));\n    return lines_1.concat(parts);\n}\nfunction printComments(path, print) {\n    var value = path.getValue();\n    var innerLines = print(path);\n    var comments = n.Node.check(value) && types.getFieldValue(value, \"comments\");\n    if (!comments || comments.length === 0) {\n        return innerLines;\n    }\n    var leadingParts = [];\n    var trailingParts = [innerLines];\n    path.each(function (commentPath) {\n        var comment = commentPath.getValue();\n        var leading = types.getFieldValue(comment, \"leading\");\n        var trailing = types.getFieldValue(comment, \"trailing\");\n        if (leading ||\n            (trailing &&\n                !(n.Statement.check(value) ||\n                    comment.type === \"Block\" ||\n                    comment.type === \"CommentBlock\"))) {\n            leadingParts.push(printLeadingComment(commentPath, print));\n        }\n        else if (trailing) {\n            trailingParts.push(printTrailingComment(commentPath, print));\n        }\n    }, \"comments\");\n    leadingParts.push.apply(leadingParts, trailingParts);\n    return lines_1.concat(leadingParts);\n}\nexports.printComments = printComments;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}